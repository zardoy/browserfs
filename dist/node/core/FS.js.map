{"version":3,"file":"FS.js","sourceRoot":"","sources":["../../../src/core/FS.ts"],"names":[],"mappings":"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","sourcesContent":["import { File } from './file';\nimport { ApiError, ErrorCode } from './api_error';\nimport { FileSystem, BFSOneArgCallback, BFSCallback, BFSThreeArgCallback } from './file_system';\nimport { FileFlag } from './file_flag';\nimport * as path from 'path';\nimport { default as Stats, FilePerm } from './stats';\nimport setImmediate from '../generic/setImmediate';\nimport { Buffer } from 'buffer';\nimport Cred from './cred';\n\n// Typing info only.\nimport type * as _fs from 'fs';\n\n/** Used for unit testing. Defaults to a NOP. */\nlet wrapCbHook = function <T>(cb: T, numArgs: number): T {\n\treturn cb;\n};\n\n/**\n * Wraps a callback function, ensuring it is invoked through setImmediate.\n * @hidden\n */\nfunction wrapCb<T extends Function>(cb: T, numArgs: number): T {\n\tif (typeof cb !== 'function') {\n\t\tthrow new Error('Callback must be a function.');\n\t}\n\n\tconst hookedCb = wrapCbHook(cb, numArgs);\n\n\t// We could use `arguments`, but Function.call/apply is expensive. And we only\n\t// need to handle 1-3 arguments\n\tswitch (numArgs) {\n\t\tcase 1:\n\t\t\treturn <any>function (arg1: any) {\n\t\t\t\tsetImmediate(function () {\n\t\t\t\t\treturn hookedCb(arg1);\n\t\t\t\t});\n\t\t\t};\n\t\tcase 2:\n\t\t\treturn <any>function (arg1: any, arg2: any) {\n\t\t\t\tsetImmediate(function () {\n\t\t\t\t\treturn hookedCb(arg1, arg2);\n\t\t\t\t});\n\t\t\t};\n\t\tcase 3:\n\t\t\treturn <any>function (arg1: any, arg2: any, arg3: any) {\n\t\t\t\tsetImmediate(function () {\n\t\t\t\t\treturn hookedCb(arg1, arg2, arg3);\n\t\t\t\t});\n\t\t\t};\n\t\tdefault:\n\t\t\tthrow new Error('Invalid invocation of wrapCb.');\n\t}\n}\n\n/**\n * @hidden\n */\nfunction assertRoot(fs?: FileSystem | null): FileSystem {\n\tif (fs) {\n\t\treturn fs;\n\t}\n\tthrow new ApiError(ErrorCode.EIO, `Initialize BrowserFS with a file system using BrowserFS.initialize(filesystem)`);\n}\n\n/**\n * @hidden\n */\nfunction normalizeMode(mode: number | string | null | undefined, def: number): number {\n\tswitch (typeof mode) {\n\t\tcase 'number':\n\t\t\t// (path, flag, mode, cb?)\n\t\t\treturn <number>mode;\n\t\tcase 'string':\n\t\t\t// (path, flag, modeString, cb?)\n\t\t\tconst trueMode = parseInt(<string>mode, 8);\n\t\t\tif (!isNaN(trueMode)) {\n\t\t\t\treturn trueMode;\n\t\t\t}\n\t\t\t// Invalid string.\n\t\t\treturn def;\n\t\tdefault:\n\t\t\treturn def;\n\t}\n}\n\n/**\n * @hidden\n */\nfunction normalizeTime(time: number | Date): Date {\n\tif (time instanceof Date) {\n\t\treturn time;\n\t} else if (typeof time === 'number') {\n\t\treturn new Date(time * 1000);\n\t} else {\n\t\tthrow new ApiError(ErrorCode.EINVAL, `Invalid time.`);\n\t}\n}\n\n/**\n * @hidden\n */\nfunction normalizePath(p: string): string {\n\t// Node doesn't allow null characters in paths.\n\tif (p.indexOf('\\u0000') >= 0) {\n\t\tthrow new ApiError(ErrorCode.EINVAL, 'Path must be a string without null bytes.');\n\t} else if (p === '') {\n\t\tthrow new ApiError(ErrorCode.EINVAL, 'Path must not be empty.');\n\t}\n\treturn path.resolve(p);\n}\n\n/**\n * @hidden\n */\nfunction normalizeOptions(options: any, defEnc: string | null, defFlag: string, defMode: number | null): { encoding: string; flag: string; mode: number } {\n\t// typeof null === 'object' so special-case handing is needed.\n\tswitch (options === null ? 'null' : typeof options) {\n\t\tcase 'object':\n\t\t\treturn {\n\t\t\t\tencoding: typeof options['encoding'] !== 'undefined' ? options['encoding'] : defEnc,\n\t\t\t\tflag: typeof options['flag'] !== 'undefined' ? options['flag'] : defFlag,\n\t\t\t\tmode: normalizeMode(options['mode'], defMode!),\n\t\t\t};\n\t\tcase 'string':\n\t\t\treturn {\n\t\t\t\tencoding: options,\n\t\t\t\tflag: defFlag,\n\t\t\t\tmode: defMode!,\n\t\t\t};\n\t\tcase 'null':\n\t\tcase 'undefined':\n\t\tcase 'function':\n\t\t\treturn {\n\t\t\t\tencoding: defEnc!,\n\t\t\t\tflag: defFlag,\n\t\t\t\tmode: defMode!,\n\t\t\t};\n\t\tdefault:\n\t\t\tthrow new TypeError(`\"options\" must be a string or an object, got ${typeof options} instead.`);\n\t}\n}\n\n/**\n * The default callback is a NOP.\n * @hidden\n * @private\n */\nfunction nopCb() {\n\t// NOP.\n}\n\n/**\n * The node frontend to all filesystems.\n * This layer handles:\n *\n * * Sanity checking inputs.\n * * Normalizing paths.\n * * Resetting stack depth for asynchronous operations which may not go through\n *   the browser by wrapping all input callbacks using `setImmediate`.\n * * Performing the requested operation through the filesystem or the file\n *   descriptor, as appropriate.\n * * Handling optional arguments and setting default arguments.\n * @see http://nodejs.org/api/fs.html\n */\nexport default class FS {\n\t/* tslint:disable:variable-name */\n\t// Exported fs.Stats.\n\tpublic static Stats = Stats;\n\t/* tslint:enable:variable-name */\n\n\tpublic F_OK: number = 0;\n\tpublic R_OK: number = 4;\n\tpublic W_OK: number = 2;\n\tpublic X_OK: number = 1;\n\n\tprivate root: FileSystem | null = null;\n\tprivate cred: Cred;\n\tprivate fdMap: { [fd: number]: File } = {};\n\tprivate nextFd = 100;\n\n\t/**\n\t * Initializes the FS Modules with the given filesystem\n\t * @param rootFS the root filesystem of the FS\n\t * @param cred the credentials used for interacting with the FS\n\t * @returns\n\t */\n\tpublic initialize(rootFS: FileSystem, cred: Cred): FileSystem {\n\t\tif (!(<any>rootFS).constructor.isAvailable()) {\n\t\t\tthrow new ApiError(ErrorCode.EINVAL, 'Tried to instantiate BrowserFS with an unavailable file system.');\n\t\t}\n\t\tthis.cred = cred;\n\t\treturn (this.root = rootFS);\n\t}\n\n\t/**\n\t * converts Date or number to a fractional UNIX timestamp\n\t * Grabbed from NodeJS sources (lib/fs.js)\n\t */\n\tpublic _toUnixTimestamp(time: Date | number): number {\n\t\tif (typeof time === 'number') {\n\t\t\treturn time;\n\t\t} else if (time instanceof Date) {\n\t\t\treturn time.getTime() / 1000;\n\t\t}\n\t\tthrow new Error('Cannot parse time: ' + time);\n\t}\n\n\t/**\n\t * **NONSTANDARD**: Grab the FileSystem instance that backs this API.\n\t * @return [BrowserFS.FileSystem | null] Returns null if the file system has\n\t *   not been initialized.\n\t */\n\tpublic getRootFS(): FileSystem | null {\n\t\tif (this.root) {\n\t\t\treturn this.root;\n\t\t} else {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\t// FILE OR DIRECTORY METHODS\n\n\t/**\n\t * Asynchronous rename. No arguments other than a possible exception are given\n\t * to the completion callback.\n\t * @param oldPath\n\t * @param newPath\n\t * @param callback\n\t */\n\tpublic rename(oldPath: string, newPath: string, cb: BFSOneArgCallback = nopCb): void {\n\t\tconst newCb = wrapCb(cb, 1);\n\t\ttry {\n\t\t\tassertRoot(this.root).rename(normalizePath(oldPath), normalizePath(newPath), this.cred, newCb);\n\t\t} catch (e) {\n\t\t\tnewCb(e);\n\t\t}\n\t}\n\n\t/**\n\t * Synchronous rename.\n\t * @param oldPath\n\t * @param newPath\n\t */\n\tpublic renameSync(oldPath: string, newPath: string): void {\n\t\tassertRoot(this.root).renameSync(normalizePath(oldPath), normalizePath(newPath), this.cred);\n\t}\n\n\t/**\n\t * Test whether or not the given path exists by checking with the file system.\n\t * Then call the callback argument with either true or false.\n\t * @example Sample invocation\n\t *   fs.exists('/etc/passwd', function (exists) {\n\t *     util.debug(exists ? \"it's there\" : \"no passwd!\");\n\t *   });\n\t * @param path\n\t * @param callback\n\t */\n\tpublic exists(path: string, cb: (exists: boolean) => any = nopCb): void {\n\t\tconst newCb = wrapCb(cb, 1);\n\t\ttry {\n\t\t\treturn assertRoot(this.root).exists(normalizePath(path), this.cred, newCb);\n\t\t} catch (e) {\n\t\t\t// Doesn't return an error. If something bad happens, we assume it just\n\t\t\t// doesn't exist.\n\t\t\treturn newCb(false);\n\t\t}\n\t}\n\n\t/**\n\t * Test whether or not the given path exists by checking with the file system.\n\t * @param path\n\t * @return [boolean]\n\t */\n\tpublic existsSync(path: string): boolean {\n\t\ttry {\n\t\t\treturn assertRoot(this.root).existsSync(normalizePath(path), this.cred);\n\t\t} catch (e) {\n\t\t\t// Doesn't return an error. If something bad happens, we assume it just\n\t\t\t// doesn't exist.\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t/**\n\t * Asynchronous `stat`.\n\t * @param path\n\t * @param callback\n\t */\n\tpublic stat(path: string, cb: BFSCallback<Stats> = nopCb): void {\n\t\tconst newCb = wrapCb(cb, 2);\n\t\ttry {\n\t\t\treturn assertRoot(this.root).stat(normalizePath(path), false, this.cred, newCb);\n\t\t} catch (e) {\n\t\t\treturn newCb(e);\n\t\t}\n\t}\n\n\t/**\n\t * Synchronous `stat`.\n\t * @param path\n\t * @return [BrowserFS.node.fs.Stats]\n\t */\n\tpublic statSync(path: string): Stats {\n\t\treturn assertRoot(this.root).statSync(normalizePath(path), false, this.cred);\n\t}\n\n\t/**\n\t * Asynchronous `lstat`.\n\t * `lstat()` is identical to `stat()`, except that if path is a symbolic link,\n\t * then the link itself is stat-ed, not the file that it refers to.\n\t * @param path\n\t * @param callback\n\t */\n\tpublic lstat(path: string, cb: BFSCallback<Stats> = nopCb): void {\n\t\tconst newCb = wrapCb(cb, 2);\n\t\ttry {\n\t\t\treturn assertRoot(this.root).stat(normalizePath(path), true, this.cred, newCb);\n\t\t} catch (e) {\n\t\t\treturn newCb(e);\n\t\t}\n\t}\n\n\t/**\n\t * Synchronous `lstat`.\n\t * `lstat()` is identical to `stat()`, except that if path is a symbolic link,\n\t * then the link itself is stat-ed, not the file that it refers to.\n\t * @param path\n\t * @return [BrowserFS.node.fs.Stats]\n\t */\n\tpublic lstatSync(path: string): Stats {\n\t\treturn assertRoot(this.root).statSync(normalizePath(path), true, this.cred);\n\t}\n\n\t// FILE-ONLY METHODS\n\n\t/**\n\t * Asynchronous `truncate`.\n\t * @param path\n\t * @param len\n\t * @param callback\n\t */\n\tpublic truncate(path: string, cb?: BFSOneArgCallback): void;\n\tpublic truncate(path: string, len: number, cb?: BFSOneArgCallback): void;\n\tpublic truncate(path: string, arg2: any = 0, cb: BFSOneArgCallback = nopCb): void {\n\t\tlet len = 0;\n\t\tif (typeof arg2 === 'function') {\n\t\t\tcb = arg2;\n\t\t} else if (typeof arg2 === 'number') {\n\t\t\tlen = arg2;\n\t\t}\n\n\t\tconst newCb = wrapCb(cb, 1);\n\t\ttry {\n\t\t\tif (len < 0) {\n\t\t\t\tthrow new ApiError(ErrorCode.EINVAL);\n\t\t\t}\n\t\t\treturn assertRoot(this.root).truncate(normalizePath(path), len, this.cred, newCb);\n\t\t} catch (e) {\n\t\t\treturn newCb(e);\n\t\t}\n\t}\n\n\t/**\n\t * Synchronous `truncate`.\n\t * @param path\n\t * @param len\n\t */\n\tpublic truncateSync(path: string, len: number = 0): void {\n\t\tif (len < 0) {\n\t\t\tthrow new ApiError(ErrorCode.EINVAL);\n\t\t}\n\t\treturn assertRoot(this.root).truncateSync(normalizePath(path), len, this.cred);\n\t}\n\n\t/**\n\t * Asynchronous `unlink`.\n\t * @param path\n\t * @param callback\n\t */\n\tpublic unlink(path: string, cb: BFSOneArgCallback = nopCb): void {\n\t\tconst newCb = wrapCb(cb, 1);\n\t\ttry {\n\t\t\treturn assertRoot(this.root).unlink(normalizePath(path), this.cred, newCb);\n\t\t} catch (e) {\n\t\t\treturn newCb(e);\n\t\t}\n\t}\n\n\t/**\n\t * Synchronous `unlink`.\n\t * @param path\n\t */\n\tpublic unlinkSync(path: string): void {\n\t\treturn assertRoot(this.root).unlinkSync(normalizePath(path), this.cred);\n\t}\n\n\t/**\n\t * Asynchronous file open.\n\t * Exclusive mode ensures that path is newly created.\n\t *\n\t * `flags` can be:\n\t *\n\t * * `'r'` - Open file for reading. An exception occurs if the file does not exist.\n\t * * `'r+'` - Open file for reading and writing. An exception occurs if the file does not exist.\n\t * * `'rs'` - Open file for reading in synchronous mode. Instructs the filesystem to not cache writes.\n\t * * `'rs+'` - Open file for reading and writing, and opens the file in synchronous mode.\n\t * * `'w'` - Open file for writing. The file is created (if it does not exist) or truncated (if it exists).\n\t * * `'wx'` - Like 'w' but opens the file in exclusive mode.\n\t * * `'w+'` - Open file for reading and writing. The file is created (if it does not exist) or truncated (if it exists).\n\t * * `'wx+'` - Like 'w+' but opens the file in exclusive mode.\n\t * * `'a'` - Open file for appending. The file is created if it does not exist.\n\t * * `'ax'` - Like 'a' but opens the file in exclusive mode.\n\t * * `'a+'` - Open file for reading and appending. The file is created if it does not exist.\n\t * * `'ax+'` - Like 'a+' but opens the file in exclusive mode.\n\t *\n\t * @see http://www.manpagez.com/man/2/open/\n\t * @param path\n\t * @param flags\n\t * @param mode defaults to `0644`\n\t * @param callback\n\t */\n\tpublic open(path: string, flag: string, cb?: BFSCallback<number>): void;\n\tpublic open(path: string, flag: string, mode: number | string, cb?: BFSCallback<number>): void;\n\tpublic open(path: string, flag: string, arg2?: any, cb: BFSCallback<number> = nopCb): void {\n\t\tconst mode = normalizeMode(arg2, 0x1a4);\n\t\tcb = typeof arg2 === 'function' ? arg2 : cb;\n\t\tconst newCb = wrapCb(cb, 2);\n\t\ttry {\n\t\t\tassertRoot(this.root).open(normalizePath(path), FileFlag.getFileFlag(flag), mode, this.cred, (e: ApiError, file?: File) => {\n\t\t\t\tif (file) {\n\t\t\t\t\tnewCb(e, this.getFdForFile(file));\n\t\t\t\t} else {\n\t\t\t\t\tnewCb(e);\n\t\t\t\t}\n\t\t\t});\n\t\t} catch (e) {\n\t\t\tnewCb(e);\n\t\t}\n\t}\n\n\t/**\n\t * Synchronous file open.\n\t * @see http://www.manpagez.com/man/2/open/\n\t * @param path\n\t * @param flags\n\t * @param mode defaults to `0644`\n\t * @return [BrowserFS.File]\n\t */\n\tpublic openSync(path: string, flag: string, mode: number | string = 0x1a4): number {\n\t\treturn this.getFdForFile(assertRoot(this.root).openSync(normalizePath(path), FileFlag.getFileFlag(flag), normalizeMode(mode, 0x1a4), this.cred));\n\t}\n\n\t/**\n\t * Asynchronously reads the entire contents of a file.\n\t * @example Usage example\n\t *   fs.readFile('/etc/passwd', function (err, data) {\n\t *     if (err) throw err;\n\t *     console.log(data);\n\t *   });\n\t * @param filename\n\t * @param options\n\t * @option options [String] encoding The string encoding for the file contents. Defaults to `null`.\n\t * @option options [String] flag Defaults to `'r'`.\n\t * @param callback If no encoding is specified, then the raw buffer is returned.\n\t */\n\tpublic readFile(filename: string, cb: BFSCallback<Buffer>): void;\n\tpublic readFile(filename: string, options: { flag?: string }, callback?: BFSCallback<Buffer>): void;\n\tpublic readFile(filename: string, options: { encoding: string; flag?: string }, callback?: BFSCallback<string>): void;\n\tpublic readFile(filename: string, encoding: string, cb: BFSCallback<string>): void;\n\tpublic readFile(filename: string, arg2: any = {}, cb: BFSCallback<any> = nopCb) {\n\t\tconst options = normalizeOptions(arg2, null, 'r', null);\n\t\tcb = typeof arg2 === 'function' ? arg2 : cb;\n\t\tconst newCb = wrapCb(cb, 2);\n\t\ttry {\n\t\t\tconst flag = FileFlag.getFileFlag(options['flag']);\n\t\t\tif (!flag.isReadable()) {\n\t\t\t\treturn newCb(new ApiError(ErrorCode.EINVAL, 'Flag passed to readFile must allow for reading.'));\n\t\t\t}\n\t\t\treturn assertRoot(this.root).readFile(normalizePath(filename), options.encoding, flag, this.cred, newCb);\n\t\t} catch (e) {\n\t\t\treturn newCb(e);\n\t\t}\n\t}\n\n\t/**\n\t * Synchronously reads the entire contents of a file.\n\t * @param filename\n\t * @param options\n\t * @option options [String] encoding The string encoding for the file contents. Defaults to `null`.\n\t * @option options [String] flag Defaults to `'r'`.\n\t * @return [String | BrowserFS.node.Buffer]\n\t */\n\tpublic readFileSync(filename: string, options?: { flag?: string }): Buffer;\n\tpublic readFileSync(filename: string, options: { encoding: string; flag?: string }): string;\n\tpublic readFileSync(filename: string, encoding: string): string;\n\tpublic readFileSync(filename: string, arg2: any = {}): any {\n\t\tconst options = normalizeOptions(arg2, null, 'r', null);\n\t\tconst flag = FileFlag.getFileFlag(options.flag);\n\t\tif (!flag.isReadable()) {\n\t\t\tthrow new ApiError(ErrorCode.EINVAL, 'Flag passed to readFile must allow for reading.');\n\t\t}\n\t\treturn assertRoot(this.root).readFileSync(normalizePath(filename), options.encoding, flag, this.cred);\n\t}\n\n\t/**\n\t * Asynchronously writes data to a file, replacing the file if it already\n\t * exists.\n\t *\n\t * The encoding option is ignored if data is a buffer.\n\t *\n\t * @example Usage example\n\t *   fs.writeFile('message.txt', 'Hello Node', function (err) {\n\t *     if (err) throw err;\n\t *     console.log('It\\'s saved!');\n\t *   });\n\t * @param filename\n\t * @param data\n\t * @param options\n\t * @option options [String] encoding Defaults to `'utf8'`.\n\t * @option options [Number] mode Defaults to `0644`.\n\t * @option options [String] flag Defaults to `'w'`.\n\t * @param callback\n\t */\n\tpublic writeFile(filename: string, data: any, cb?: BFSOneArgCallback): void;\n\tpublic writeFile(filename: string, data: any, encoding?: string, cb?: BFSOneArgCallback): void;\n\tpublic writeFile(filename: string, data: any, options?: { encoding?: string; mode?: string | number; flag?: string }, cb?: BFSOneArgCallback): void;\n\tpublic writeFile(filename: string, data: any, arg3: any = {}, cb: BFSOneArgCallback = nopCb): void {\n\t\tconst options = normalizeOptions(arg3, 'utf8', 'w', 0x1a4);\n\t\tcb = typeof arg3 === 'function' ? arg3 : cb;\n\t\tconst newCb = wrapCb(cb, 1);\n\t\ttry {\n\t\t\tconst flag = FileFlag.getFileFlag(options.flag);\n\t\t\tif (!flag.isWriteable()) {\n\t\t\t\treturn newCb(new ApiError(ErrorCode.EINVAL, 'Flag passed to writeFile must allow for writing.'));\n\t\t\t}\n\t\t\treturn assertRoot(this.root).writeFile(normalizePath(filename), data, options.encoding, flag, options.mode, this.cred, newCb);\n\t\t} catch (e) {\n\t\t\treturn newCb(e);\n\t\t}\n\t}\n\n\t/**\n\t * Synchronously writes data to a file, replacing the file if it already\n\t * exists.\n\t *\n\t * The encoding option is ignored if data is a buffer.\n\t * @param filename\n\t * @param data\n\t * @param options\n\t * @option options [String] encoding Defaults to `'utf8'`.\n\t * @option options [Number] mode Defaults to `0644`.\n\t * @option options [String] flag Defaults to `'w'`.\n\t */\n\tpublic writeFileSync(filename: string, data: any, options?: { encoding?: string; mode?: number | string; flag?: string }): void;\n\tpublic writeFileSync(filename: string, data: any, encoding?: string): void;\n\tpublic writeFileSync(filename: string, data: any, arg3?: any): void {\n\t\tconst options = normalizeOptions(arg3, 'utf8', 'w', 0x1a4);\n\t\tconst flag = FileFlag.getFileFlag(options.flag);\n\t\tif (!flag.isWriteable()) {\n\t\t\tthrow new ApiError(ErrorCode.EINVAL, 'Flag passed to writeFile must allow for writing.');\n\t\t}\n\t\treturn assertRoot(this.root).writeFileSync(normalizePath(filename), data, options.encoding, flag, options.mode, this.cred);\n\t}\n\n\t/**\n\t * Asynchronously append data to a file, creating the file if it not yet\n\t * exists.\n\t *\n\t * @example Usage example\n\t *   fs.appendFile('message.txt', 'data to append', function (err) {\n\t *     if (err) throw err;\n\t *     console.log('The \"data to append\" was appended to file!');\n\t *   });\n\t * @param filename\n\t * @param data\n\t * @param options\n\t * @option options [String] encoding Defaults to `'utf8'`.\n\t * @option options [Number] mode Defaults to `0644`.\n\t * @option options [String] flag Defaults to `'a'`.\n\t * @param callback\n\t */\n\tpublic appendFile(filename: string, data: any, cb?: BFSOneArgCallback): void;\n\tpublic appendFile(filename: string, data: any, options?: { encoding?: string; mode?: number | string; flag?: string }, cb?: BFSOneArgCallback): void;\n\tpublic appendFile(filename: string, data: any, encoding?: string, cb?: BFSOneArgCallback): void;\n\tpublic appendFile(filename: string, data: any, arg3?: any, cb: BFSOneArgCallback = nopCb): void {\n\t\tconst options = normalizeOptions(arg3, 'utf8', 'a', 0x1a4);\n\t\tcb = typeof arg3 === 'function' ? arg3 : cb;\n\t\tconst newCb = wrapCb(cb, 1);\n\t\ttry {\n\t\t\tconst flag = FileFlag.getFileFlag(options.flag);\n\t\t\tif (!flag.isAppendable()) {\n\t\t\t\treturn newCb(new ApiError(ErrorCode.EINVAL, 'Flag passed to appendFile must allow for appending.'));\n\t\t\t}\n\t\t\tassertRoot(this.root).appendFile(normalizePath(filename), data, options.encoding, flag, options.mode, this.cred, newCb);\n\t\t} catch (e) {\n\t\t\tnewCb(e);\n\t\t}\n\t}\n\n\t/**\n\t * Asynchronously append data to a file, creating the file if it not yet\n\t * exists.\n\t *\n\t * @example Usage example\n\t *   fs.appendFile('message.txt', 'data to append', function (err) {\n\t *     if (err) throw err;\n\t *     console.log('The \"data to append\" was appended to file!');\n\t *   });\n\t * @param filename\n\t * @param data\n\t * @param options\n\t * @option options [String] encoding Defaults to `'utf8'`.\n\t * @option options [Number] mode Defaults to `0644`.\n\t * @option options [String] flag Defaults to `'a'`.\n\t */\n\tpublic appendFileSync(filename: string, data: any, options?: { encoding?: string; mode?: number | string; flag?: string }): void;\n\tpublic appendFileSync(filename: string, data: any, encoding?: string): void;\n\tpublic appendFileSync(filename: string, data: any, arg3?: any): void {\n\t\tconst options = normalizeOptions(arg3, 'utf8', 'a', 0x1a4);\n\t\tconst flag = FileFlag.getFileFlag(options.flag);\n\t\tif (!flag.isAppendable()) {\n\t\t\tthrow new ApiError(ErrorCode.EINVAL, 'Flag passed to appendFile must allow for appending.');\n\t\t}\n\t\treturn assertRoot(this.root).appendFileSync(normalizePath(filename), data, options.encoding, flag, options.mode, this.cred);\n\t}\n\n\t// FILE DESCRIPTOR METHODS\n\n\t/**\n\t * Asynchronous `fstat`.\n\t * `fstat()` is identical to `stat()`, except that the file to be stat-ed is\n\t * specified by the file descriptor `fd`.\n\t * @param fd\n\t * @param callback\n\t */\n\tpublic fstat(fd: number, cb: BFSCallback<Stats> = nopCb): void {\n\t\tconst newCb = wrapCb(cb, 2);\n\t\ttry {\n\t\t\tconst file = this.fd2file(fd);\n\t\t\tfile.stat(newCb);\n\t\t} catch (e) {\n\t\t\tnewCb(e);\n\t\t}\n\t}\n\n\t/**\n\t * Synchronous `fstat`.\n\t * `fstat()` is identical to `stat()`, except that the file to be stat-ed is\n\t * specified by the file descriptor `fd`.\n\t * @param fd\n\t * @return [BrowserFS.node.fs.Stats]\n\t */\n\tpublic fstatSync(fd: number): Stats {\n\t\treturn this.fd2file(fd).statSync();\n\t}\n\n\t/**\n\t * Asynchronous close.\n\t * @param fd\n\t * @param callback\n\t */\n\tpublic close(fd: number, cb: BFSOneArgCallback = nopCb): void {\n\t\tconst newCb = wrapCb(cb, 1);\n\t\ttry {\n\t\t\tthis.fd2file(fd).close((e: ApiError) => {\n\t\t\t\tif (!e) {\n\t\t\t\t\tthis.closeFd(fd);\n\t\t\t\t}\n\t\t\t\tnewCb(e);\n\t\t\t});\n\t\t} catch (e) {\n\t\t\tnewCb(e);\n\t\t}\n\t}\n\n\t/**\n\t * Synchronous close.\n\t * @param fd\n\t */\n\tpublic closeSync(fd: number): void {\n\t\tthis.fd2file(fd).closeSync();\n\t\tthis.closeFd(fd);\n\t}\n\n\t/**\n\t * Asynchronous ftruncate.\n\t * @param fd\n\t * @param len\n\t * @param callback\n\t */\n\tpublic ftruncate(fd: number, cb?: BFSOneArgCallback): void;\n\tpublic ftruncate(fd: number, len?: number, cb?: BFSOneArgCallback): void;\n\tpublic ftruncate(fd: number, arg2?: any, cb: BFSOneArgCallback = nopCb): void {\n\t\tconst length = typeof arg2 === 'number' ? arg2 : 0;\n\t\tcb = typeof arg2 === 'function' ? arg2 : cb;\n\t\tconst newCb = wrapCb(cb, 1);\n\t\ttry {\n\t\t\tconst file = this.fd2file(fd);\n\t\t\tif (length < 0) {\n\t\t\t\tthrow new ApiError(ErrorCode.EINVAL);\n\t\t\t}\n\t\t\tfile.truncate(length, newCb);\n\t\t} catch (e) {\n\t\t\tnewCb(e);\n\t\t}\n\t}\n\n\t/**\n\t * Synchronous ftruncate.\n\t * @param fd\n\t * @param len\n\t */\n\tpublic ftruncateSync(fd: number, len: number = 0): void {\n\t\tconst file = this.fd2file(fd);\n\t\tif (len < 0) {\n\t\t\tthrow new ApiError(ErrorCode.EINVAL);\n\t\t}\n\t\tfile.truncateSync(len);\n\t}\n\n\t/**\n\t * Asynchronous fsync.\n\t * @param fd\n\t * @param callback\n\t */\n\tpublic fsync(fd: number, cb: BFSOneArgCallback = nopCb): void {\n\t\tconst newCb = wrapCb(cb, 1);\n\t\ttry {\n\t\t\tthis.fd2file(fd).sync(newCb);\n\t\t} catch (e) {\n\t\t\tnewCb(e);\n\t\t}\n\t}\n\n\t/**\n\t * Synchronous fsync.\n\t * @param fd\n\t */\n\tpublic fsyncSync(fd: number): void {\n\t\tthis.fd2file(fd).syncSync();\n\t}\n\n\t/**\n\t * Asynchronous fdatasync.\n\t * @param fd\n\t * @param callback\n\t */\n\tpublic fdatasync(fd: number, cb: BFSOneArgCallback = nopCb): void {\n\t\tconst newCb = wrapCb(cb, 1);\n\t\ttry {\n\t\t\tthis.fd2file(fd).datasync(newCb);\n\t\t} catch (e) {\n\t\t\tnewCb(e);\n\t\t}\n\t}\n\n\t/**\n\t * Synchronous fdatasync.\n\t * @param fd\n\t */\n\tpublic fdatasyncSync(fd: number): void {\n\t\tthis.fd2file(fd).datasyncSync();\n\t}\n\n\t/**\n\t * Write buffer to the file specified by `fd`.\n\t * Note that it is unsafe to use fs.write multiple times on the same file\n\t * without waiting for the callback.\n\t * @param fd\n\t * @param buffer Buffer containing the data to write to\n\t *   the file.\n\t * @param offset Offset in the buffer to start reading data from.\n\t * @param length The amount of bytes to write to the file.\n\t * @param position Offset from the beginning of the file where this\n\t *   data should be written. If position is null, the data will be written at\n\t *   the current position.\n\t * @param callback The number specifies the number of bytes written into the file.\n\t */\n\tpublic write(fd: number, buffer: Buffer, offset: number, length: number, cb?: BFSThreeArgCallback<number, Buffer>): void;\n\tpublic write(fd: number, buffer: Buffer, offset: number, length: number, position: number | null, cb?: BFSThreeArgCallback<number, Buffer>): void;\n\tpublic write(fd: number, data: any, cb?: BFSThreeArgCallback<number, string>): void;\n\tpublic write(fd: number, data: any, position: number | null, cb?: BFSThreeArgCallback<number, string>): void;\n\tpublic write(fd: number, data: any, position: number | null, encoding: BufferEncoding, cb?: BFSThreeArgCallback<number, string>): void;\n\tpublic write(fd: number, arg2: any, arg3?: any, arg4?: any, arg5?: any, cb: BFSThreeArgCallback<number, any> = nopCb): void {\n\t\tlet buffer: Buffer,\n\t\t\toffset: number,\n\t\t\tlength: number,\n\t\t\tposition: number | null = null;\n\t\tif (typeof arg2 === 'string') {\n\t\t\t// Signature 1: (fd, string, [position?, [encoding?]], cb?)\n\t\t\tlet encoding: BufferEncoding = 'utf8';\n\t\t\tswitch (typeof arg3) {\n\t\t\t\tcase 'function':\n\t\t\t\t\t// (fd, string, cb)\n\t\t\t\t\tcb = arg3;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'number':\n\t\t\t\t\t// (fd, string, position, encoding?, cb?)\n\t\t\t\t\tposition = arg3;\n\t\t\t\t\tencoding = (typeof arg4 === 'string' ? arg4 : 'utf8') as BufferEncoding;\n\t\t\t\t\tcb = typeof arg5 === 'function' ? arg5 : cb;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\t// ...try to find the callback and get out of here!\n\t\t\t\t\tcb = typeof arg4 === 'function' ? arg4 : typeof arg5 === 'function' ? arg5 : cb;\n\t\t\t\t\treturn cb(new ApiError(ErrorCode.EINVAL, 'Invalid arguments.'));\n\t\t\t}\n\t\t\tbuffer = Buffer.from(arg2, encoding);\n\t\t\toffset = 0;\n\t\t\tlength = buffer.length;\n\t\t} else {\n\t\t\t// Signature 2: (fd, buffer, offset, length, position?, cb?)\n\t\t\tbuffer = arg2;\n\t\t\toffset = arg3;\n\t\t\tlength = arg4;\n\t\t\tposition = typeof arg5 === 'number' ? arg5 : null;\n\t\t\tcb = typeof arg5 === 'function' ? arg5 : cb;\n\t\t}\n\n\t\tconst newCb = wrapCb(cb, 3);\n\t\ttry {\n\t\t\tconst file = this.fd2file(fd);\n\t\t\tif (position === undefined || position === null) {\n\t\t\t\tposition = file.getPos()!;\n\t\t\t}\n\t\t\tfile.write(buffer, offset, length, position, newCb);\n\t\t} catch (e) {\n\t\t\tnewCb(e);\n\t\t}\n\t}\n\n\t/**\n\t * Write buffer to the file specified by `fd`.\n\t * Note that it is unsafe to use fs.write multiple times on the same file\n\t * without waiting for it to return.\n\t * @param fd\n\t * @param buffer Buffer containing the data to write to\n\t *   the file.\n\t * @param offset Offset in the buffer to start reading data from.\n\t * @param length The amount of bytes to write to the file.\n\t * @param position Offset from the beginning of the file where this\n\t *   data should be written. If position is null, the data will be written at\n\t *   the current position.\n\t */\n\tpublic writeSync(fd: number, buffer: Buffer, offset: number, length: number, position?: number | null): number;\n\tpublic writeSync(fd: number, data: string, position?: number | null, encoding?: BufferEncoding): number;\n\tpublic writeSync(fd: number, arg2: any, arg3?: any, arg4?: any, arg5?: any): number {\n\t\tlet buffer: Buffer,\n\t\t\toffset: number = 0,\n\t\t\tlength: number,\n\t\t\tposition: number | null;\n\t\tif (typeof arg2 === 'string') {\n\t\t\t// Signature 1: (fd, string, [position?, [encoding?]])\n\t\t\tposition = typeof arg3 === 'number' ? arg3 : null;\n\t\t\tconst encoding = (typeof arg4 === 'string' ? arg4 : 'utf8') as BufferEncoding;\n\t\t\toffset = 0;\n\t\t\tbuffer = Buffer.from(arg2, encoding);\n\t\t\tlength = buffer.length;\n\t\t} else {\n\t\t\t// Signature 2: (fd, buffer, offset, length, position?)\n\t\t\tbuffer = arg2;\n\t\t\toffset = arg3;\n\t\t\tlength = arg4;\n\t\t\tposition = typeof arg5 === 'number' ? arg5 : null;\n\t\t}\n\n\t\tconst file = this.fd2file(fd);\n\t\tif (position === undefined || position === null) {\n\t\t\tposition = file.getPos()!;\n\t\t}\n\t\treturn file.writeSync(buffer, offset, length, position);\n\t}\n\n\t/**\n\t * Read data from the file specified by `fd`.\n\t * @param buffer The buffer that the data will be\n\t *   written to.\n\t * @param offset The offset within the buffer where writing will\n\t *   start.\n\t * @param length An integer specifying the number of bytes to read.\n\t * @param position An integer specifying where to begin reading from\n\t *   in the file. If position is null, data will be read from the current file\n\t *   position.\n\t * @param callback The number is the number of bytes read\n\t */\n\tpublic read(fd: number, length: number, position: number | null, encoding: string, cb?: BFSThreeArgCallback<string, number>): void;\n\tpublic read(fd: number, buffer: Buffer, offset: number, length: number, position: number | null, cb?: BFSThreeArgCallback<number, Buffer>): void;\n\tpublic read(fd: number, arg2: any, arg3: any, arg4: any, arg5?: any, cb: BFSThreeArgCallback<string, number> | BFSThreeArgCallback<number, Buffer> = nopCb): void {\n\t\tlet position: number | null, offset: number, length: number, buffer: Buffer, newCb: BFSThreeArgCallback<number, Buffer>;\n\t\tif (typeof arg2 === 'number') {\n\t\t\t// legacy interface\n\t\t\t// (fd, length, position, encoding, callback)\n\t\t\tlength = arg2;\n\t\t\tposition = arg3;\n\t\t\tconst encoding = arg4;\n\t\t\tcb = typeof arg5 === 'function' ? arg5 : cb;\n\t\t\toffset = 0;\n\t\t\tbuffer = Buffer.alloc(length);\n\t\t\t// XXX: Inefficient.\n\t\t\t// Wrap the cb so we shelter upper layers of the API from these\n\t\t\t// shenanigans.\n\t\t\tnewCb = wrapCb((err?: ApiError | null, bytesRead?: number, buf?: Buffer) => {\n\t\t\t\tif (err) {\n\t\t\t\t\treturn (<Function>cb)(err);\n\t\t\t\t}\n\t\t\t\t(<BFSThreeArgCallback<string, number>>cb)(err, buf!.toString(encoding), bytesRead!);\n\t\t\t}, 3);\n\t\t} else {\n\t\t\tbuffer = arg2;\n\t\t\toffset = arg3;\n\t\t\tlength = arg4;\n\t\t\tposition = arg5;\n\t\t\tnewCb = wrapCb(<BFSThreeArgCallback<number, Buffer>>cb, 3);\n\t\t}\n\n\t\ttry {\n\t\t\tconst file = this.fd2file(fd);\n\t\t\tif (position === undefined || position === null) {\n\t\t\t\tposition = file.getPos()!;\n\t\t\t}\n\t\t\tfile.read(buffer, offset, length, position, newCb);\n\t\t} catch (e) {\n\t\t\tnewCb(e);\n\t\t}\n\t}\n\n\t/**\n\t * Read data from the file specified by `fd`.\n\t * @param fd\n\t * @param buffer The buffer that the data will be\n\t *   written to.\n\t * @param offset The offset within the buffer where writing will\n\t *   start.\n\t * @param length An integer specifying the number of bytes to read.\n\t * @param position An integer specifying where to begin reading from\n\t *   in the file. If position is null, data will be read from the current file\n\t *   position.\n\t * @return [Number]\n\t */\n\tpublic readSync(fd: number, length: number, position: number, encoding: BufferEncoding): string;\n\tpublic readSync(fd: number, buffer: Buffer, offset: number, length: number, position: number): number;\n\tpublic readSync(fd: number, arg2: any, arg3: any, arg4: any, arg5?: any): any {\n\t\tlet shenanigans = false;\n\t\tlet buffer: Buffer,\n\t\t\toffset: number,\n\t\t\tlength: number,\n\t\t\tposition: number,\n\t\t\tencoding: BufferEncoding = 'utf8';\n\t\tif (typeof arg2 === 'number') {\n\t\t\tlength = arg2;\n\t\t\tposition = arg3;\n\t\t\tencoding = arg4;\n\t\t\toffset = 0;\n\t\t\tbuffer = Buffer.alloc(length);\n\t\t\tshenanigans = true;\n\t\t} else {\n\t\t\tbuffer = arg2;\n\t\t\toffset = arg3;\n\t\t\tlength = arg4;\n\t\t\tposition = arg5;\n\t\t}\n\t\tconst file = this.fd2file(fd);\n\t\tif (position === undefined || position === null) {\n\t\t\tposition = file.getPos()!;\n\t\t}\n\n\t\tconst rv = file.readSync(buffer, offset, length, position);\n\t\tif (!shenanigans) {\n\t\t\treturn rv;\n\t\t} else {\n\t\t\treturn [buffer.toString(encoding), rv];\n\t\t}\n\t}\n\n\t/**\n\t * Asynchronous `fchown`.\n\t * @param fd\n\t * @param uid\n\t * @param gid\n\t * @param callback\n\t */\n\tpublic fchown(fd: number, uid: number, gid: number, callback: BFSOneArgCallback = nopCb): void {\n\t\tconst newCb = wrapCb(callback, 1);\n\t\ttry {\n\t\t\tthis.fd2file(fd).chown(uid, gid, newCb);\n\t\t} catch (e) {\n\t\t\tnewCb(e);\n\t\t}\n\t}\n\n\t/**\n\t * Synchronous `fchown`.\n\t * @param fd\n\t * @param uid\n\t * @param gid\n\t */\n\tpublic fchownSync(fd: number, uid: number, gid: number): void {\n\t\tthis.fd2file(fd).chownSync(uid, gid);\n\t}\n\n\t/**\n\t * Asynchronous `fchmod`.\n\t * @param fd\n\t * @param mode\n\t * @param callback\n\t */\n\tpublic fchmod(fd: number, mode: string | number, cb: BFSOneArgCallback): void {\n\t\tconst newCb = wrapCb(cb, 1);\n\t\ttry {\n\t\t\tconst numMode = typeof mode === 'string' ? parseInt(mode, 8) : mode;\n\t\t\tthis.fd2file(fd).chmod(numMode, newCb);\n\t\t} catch (e) {\n\t\t\tnewCb(e);\n\t\t}\n\t}\n\n\t/**\n\t * Synchronous `fchmod`.\n\t * @param fd\n\t * @param mode\n\t */\n\tpublic fchmodSync(fd: number, mode: number | string): void {\n\t\tconst numMode = typeof mode === 'string' ? parseInt(mode, 8) : mode;\n\t\tthis.fd2file(fd).chmodSync(numMode);\n\t}\n\n\t/**\n\t * Change the file timestamps of a file referenced by the supplied file\n\t * descriptor.\n\t * @param fd\n\t * @param atime\n\t * @param mtime\n\t * @param callback\n\t */\n\tpublic futimes(fd: number, atime: number | Date, mtime: number | Date, cb: BFSOneArgCallback = nopCb): void {\n\t\tconst newCb = wrapCb(cb, 1);\n\t\ttry {\n\t\t\tconst file = this.fd2file(fd);\n\t\t\tif (typeof atime === 'number') {\n\t\t\t\tatime = new Date(atime * 1000);\n\t\t\t}\n\t\t\tif (typeof mtime === 'number') {\n\t\t\t\tmtime = new Date(mtime * 1000);\n\t\t\t}\n\t\t\tfile.utimes(atime, mtime, newCb);\n\t\t} catch (e) {\n\t\t\tnewCb(e);\n\t\t}\n\t}\n\n\t/**\n\t * Change the file timestamps of a file referenced by the supplied file\n\t * descriptor.\n\t * @param fd\n\t * @param atime\n\t * @param mtime\n\t */\n\tpublic futimesSync(fd: number, atime: number | Date, mtime: number | Date): void {\n\t\tthis.fd2file(fd).utimesSync(normalizeTime(atime), normalizeTime(mtime));\n\t}\n\n\t// DIRECTORY-ONLY METHODS\n\n\t/**\n\t * Asynchronous `rmdir`.\n\t * @param path\n\t * @param callback\n\t */\n\tpublic rmdir(path: string, cb: BFSOneArgCallback = nopCb): void {\n\t\tconst newCb = wrapCb(cb, 1);\n\t\ttry {\n\t\t\tpath = normalizePath(path);\n\t\t\tassertRoot(this.root).rmdir(path, this.cred, newCb);\n\t\t} catch (e) {\n\t\t\tnewCb(e);\n\t\t}\n\t}\n\n\t/**\n\t * Synchronous `rmdir`.\n\t * @param path\n\t */\n\tpublic rmdirSync(path: string): void {\n\t\tpath = normalizePath(path);\n\t\treturn assertRoot(this.root).rmdirSync(path, this.cred);\n\t}\n\n\t/**\n\t * Asynchronous `mkdir`.\n\t * @param path\n\t * @param mode defaults to `0777`\n\t * @param callback\n\t */\n\tpublic mkdir(path: string, mode?: any, cb: BFSOneArgCallback = nopCb): void {\n\t\tif (typeof mode === 'function') {\n\t\t\tcb = mode;\n\t\t\tmode = 0x1ff;\n\t\t}\n\t\tconst newCb = wrapCb(cb, 1);\n\t\ttry {\n\t\t\tpath = normalizePath(path);\n\t\t\tassertRoot(this.root).mkdir(path, mode, this.cred, newCb);\n\t\t} catch (e) {\n\t\t\tnewCb(e);\n\t\t}\n\t}\n\n\t/**\n\t * Synchronous `mkdir`.\n\t * @param path\n\t * @param mode defaults to `0777`\n\t */\n\tpublic mkdirSync(path: string, mode?: number | string): void {\n\t\tassertRoot(this.root).mkdirSync(normalizePath(path), normalizeMode(mode, 0x1ff), this.cred);\n\t}\n\n\t/**\n\t * Asynchronous `readdir`. Reads the contents of a directory.\n\t * The callback gets two arguments `(err, files)` where `files` is an array of\n\t * the names of the files in the directory excluding `'.'` and `'..'`.\n\t * @param path\n\t * @param callback\n\t */\n\tpublic readdir(path: string, cb: BFSCallback<string[]> = nopCb): void {\n\t\tconst newCb = <(err: ApiError, files?: string[]) => void>wrapCb(cb, 2);\n\t\ttry {\n\t\t\tpath = normalizePath(path);\n\t\t\tassertRoot(this.root).readdir(path, this.cred, newCb);\n\t\t} catch (e) {\n\t\t\tnewCb(e);\n\t\t}\n\t}\n\n\t/**\n\t * Synchronous `readdir`. Reads the contents of a directory.\n\t * @param path\n\t * @return [String[]]\n\t */\n\tpublic readdirSync(path: string): string[] {\n\t\tpath = normalizePath(path);\n\t\treturn assertRoot(this.root).readdirSync(path, this.cred);\n\t}\n\n\t// SYMLINK METHODS\n\n\t/**\n\t * Asynchronous `link`.\n\t * @param srcpath\n\t * @param dstpath\n\t * @param callback\n\t */\n\tpublic link(srcpath: string, dstpath: string, cb: BFSOneArgCallback = nopCb): void {\n\t\tconst newCb = wrapCb(cb, 1);\n\t\ttry {\n\t\t\tsrcpath = normalizePath(srcpath);\n\t\t\tdstpath = normalizePath(dstpath);\n\t\t\tassertRoot(this.root).link(srcpath, dstpath, this.cred, newCb);\n\t\t} catch (e) {\n\t\t\tnewCb(e);\n\t\t}\n\t}\n\n\t/**\n\t * Synchronous `link`.\n\t * @param srcpath\n\t * @param dstpath\n\t */\n\tpublic linkSync(srcpath: string, dstpath: string): void {\n\t\tsrcpath = normalizePath(srcpath);\n\t\tdstpath = normalizePath(dstpath);\n\t\treturn assertRoot(this.root).linkSync(srcpath, dstpath, this.cred);\n\t}\n\n\t/**\n\t * Asynchronous `symlink`.\n\t * @param srcpath\n\t * @param dstpath\n\t * @param type can be either `'dir'` or `'file'` (default is `'file'`)\n\t * @param callback\n\t */\n\tpublic symlink(srcpath: string, dstpath: string, cb?: BFSOneArgCallback): void;\n\tpublic symlink(srcpath: string, dstpath: string, type?: string, cb?: BFSOneArgCallback): void;\n\tpublic symlink(srcpath: string, dstpath: string, arg3?: any, cb: BFSOneArgCallback = nopCb): void {\n\t\tconst type = typeof arg3 === 'string' ? arg3 : 'file';\n\t\tcb = typeof arg3 === 'function' ? arg3 : cb;\n\t\tconst newCb = wrapCb(cb, 1);\n\t\ttry {\n\t\t\tif (type !== 'file' && type !== 'dir') {\n\t\t\t\treturn newCb(new ApiError(ErrorCode.EINVAL, 'Invalid type: ' + type));\n\t\t\t}\n\t\t\tsrcpath = normalizePath(srcpath);\n\t\t\tdstpath = normalizePath(dstpath);\n\t\t\tassertRoot(this.root).symlink(srcpath, dstpath, type, this.cred, newCb);\n\t\t} catch (e) {\n\t\t\tnewCb(e);\n\t\t}\n\t}\n\n\t/**\n\t * Synchronous `symlink`.\n\t * @param srcpath\n\t * @param dstpath\n\t * @param type can be either `'dir'` or `'file'` (default is `'file'`)\n\t */\n\tpublic symlinkSync(srcpath: string, dstpath: string, type?: string): void {\n\t\tif (!type) {\n\t\t\ttype = 'file';\n\t\t} else if (type !== 'file' && type !== 'dir') {\n\t\t\tthrow new ApiError(ErrorCode.EINVAL, 'Invalid type: ' + type);\n\t\t}\n\t\tsrcpath = normalizePath(srcpath);\n\t\tdstpath = normalizePath(dstpath);\n\t\treturn assertRoot(this.root).symlinkSync(srcpath, dstpath, type, this.cred);\n\t}\n\n\t/**\n\t * Asynchronous readlink.\n\t * @param path\n\t * @param callback\n\t */\n\tpublic readlink(path: string, cb: BFSCallback<string> = nopCb): void {\n\t\tconst newCb = wrapCb(cb, 2);\n\t\ttry {\n\t\t\tpath = normalizePath(path);\n\t\t\tassertRoot(this.root).readlink(path, this.cred, newCb);\n\t\t} catch (e) {\n\t\t\tnewCb(e);\n\t\t}\n\t}\n\n\t/**\n\t * Synchronous readlink.\n\t * @param path\n\t * @return [String]\n\t */\n\tpublic readlinkSync(path: string): string {\n\t\tpath = normalizePath(path);\n\t\treturn assertRoot(this.root).readlinkSync(path, this.cred);\n\t}\n\n\t// PROPERTY OPERATIONS\n\n\t/**\n\t * Asynchronous `chown`.\n\t * @param path\n\t * @param uid\n\t * @param gid\n\t * @param callback\n\t */\n\tpublic chown(path: string, uid: number, gid: number, cb: BFSOneArgCallback = nopCb): void {\n\t\tconst newCb = wrapCb(cb, 1);\n\t\ttry {\n\t\t\tpath = normalizePath(path);\n\t\t\tassertRoot(this.root).chown(path, false, uid, gid, this.cred, newCb);\n\t\t} catch (e) {\n\t\t\tnewCb(e);\n\t\t}\n\t}\n\n\t/**\n\t * Synchronous `chown`.\n\t * @param path\n\t * @param uid\n\t * @param gid\n\t */\n\tpublic chownSync(path: string, uid: number, gid: number): void {\n\t\tpath = normalizePath(path);\n\t\tassertRoot(this.root).chownSync(path, false, uid, gid, this.cred);\n\t}\n\n\t/**\n\t * Asynchronous `lchown`.\n\t * @param path\n\t * @param uid\n\t * @param gid\n\t * @param callback\n\t */\n\tpublic lchown(path: string, uid: number, gid: number, cb: BFSOneArgCallback = nopCb): void {\n\t\tconst newCb = wrapCb(cb, 1);\n\t\ttry {\n\t\t\tpath = normalizePath(path);\n\t\t\tassertRoot(this.root).chown(path, true, uid, gid, this.cred, newCb);\n\t\t} catch (e) {\n\t\t\tnewCb(e);\n\t\t}\n\t}\n\n\t/**\n\t * Synchronous `lchown`.\n\t * @param path\n\t * @param uid\n\t * @param gid\n\t */\n\tpublic lchownSync(path: string, uid: number, gid: number): void {\n\t\tpath = normalizePath(path);\n\t\tassertRoot(this.root).chownSync(path, true, uid, gid, this.cred);\n\t}\n\n\t/**\n\t * Asynchronous `chmod`.\n\t * @param path\n\t * @param mode\n\t * @param callback\n\t */\n\tpublic chmod(path: string, mode: number | string, cb: BFSOneArgCallback = nopCb): void {\n\t\tconst newCb = wrapCb(cb, 1);\n\t\ttry {\n\t\t\tconst numMode = normalizeMode(mode, -1);\n\t\t\tif (numMode < 0) {\n\t\t\t\tthrow new ApiError(ErrorCode.EINVAL, `Invalid mode.`);\n\t\t\t}\n\t\t\tassertRoot(this.root).chmod(normalizePath(path), false, numMode, this.cred, newCb);\n\t\t} catch (e) {\n\t\t\tnewCb(e);\n\t\t}\n\t}\n\n\t/**\n\t * Synchronous `chmod`.\n\t * @param path\n\t * @param mode\n\t */\n\tpublic chmodSync(path: string, mode: string | number): void {\n\t\tconst numMode = normalizeMode(mode, -1);\n\t\tif (numMode < 0) {\n\t\t\tthrow new ApiError(ErrorCode.EINVAL, `Invalid mode.`);\n\t\t}\n\t\tpath = normalizePath(path);\n\t\tassertRoot(this.root).chmodSync(path, false, numMode, this.cred);\n\t}\n\n\t/**\n\t * Asynchronous `lchmod`.\n\t * @param path\n\t * @param mode\n\t * @param callback\n\t */\n\tpublic lchmod(path: string, mode: number | string, cb: BFSOneArgCallback = nopCb): void {\n\t\tconst newCb = wrapCb(cb, 1);\n\t\ttry {\n\t\t\tconst numMode = normalizeMode(mode, -1);\n\t\t\tif (numMode < 0) {\n\t\t\t\tthrow new ApiError(ErrorCode.EINVAL, `Invalid mode.`);\n\t\t\t}\n\t\t\tassertRoot(this.root).chmod(normalizePath(path), true, numMode, this.cred, newCb);\n\t\t} catch (e) {\n\t\t\tnewCb(e);\n\t\t}\n\t}\n\n\t/**\n\t * Synchronous `lchmod`.\n\t * @param path\n\t * @param mode\n\t */\n\tpublic lchmodSync(path: string, mode: number | string): void {\n\t\tconst numMode = normalizeMode(mode, -1);\n\t\tif (numMode < 1) {\n\t\t\tthrow new ApiError(ErrorCode.EINVAL, `Invalid mode.`);\n\t\t}\n\t\tassertRoot(this.root).chmodSync(normalizePath(path), true, numMode, this.cred);\n\t}\n\n\t/**\n\t * Change file timestamps of the file referenced by the supplied path.\n\t * @param path\n\t * @param atime\n\t * @param mtime\n\t * @param callback\n\t */\n\tpublic utimes(path: string, atime: number | Date, mtime: number | Date, cb: BFSOneArgCallback = nopCb): void {\n\t\tconst newCb = wrapCb(cb, 1);\n\t\ttry {\n\t\t\tassertRoot(this.root).utimes(normalizePath(path), normalizeTime(atime), normalizeTime(mtime), this.cred, newCb);\n\t\t} catch (e) {\n\t\t\tnewCb(e);\n\t\t}\n\t}\n\n\t/**\n\t * Change file timestamps of the file referenced by the supplied path.\n\t * @param path\n\t * @param atime\n\t * @param mtime\n\t */\n\tpublic utimesSync(path: string, atime: number | Date, mtime: number | Date): void {\n\t\tassertRoot(this.root).utimesSync(normalizePath(path), normalizeTime(atime), normalizeTime(mtime), this.cred);\n\t}\n\n\t/**\n\t * Asynchronous `realpath`. The callback gets two arguments\n\t * `(err, resolvedPath)`. May use `process.cwd` to resolve relative paths.\n\t *\n\t * @example Usage example\n\t *   let cache = {'/etc':'/private/etc'};\n\t *   fs.realpath('/etc/passwd', cache, function (err, resolvedPath) {\n\t *     if (err) throw err;\n\t *     console.log(resolvedPath);\n\t *   });\n\t *\n\t * @param path\n\t * @param cache An object literal of mapped paths that can be used to\n\t *   force a specific path resolution or avoid additional `fs.stat` calls for\n\t *   known real paths.\n\t * @param callback\n\t */\n\tpublic realpath(path: string, cb?: BFSCallback<string>): void;\n\tpublic realpath(path: string, cache: { [path: string]: string }, cb: BFSCallback<string>): void;\n\tpublic realpath(path: string, arg2?: any, cb: BFSCallback<string> = nopCb): void {\n\t\tconst cache = typeof arg2 === 'object' ? arg2 : {};\n\t\tcb = typeof arg2 === 'function' ? arg2 : nopCb;\n\t\tconst newCb = <(err: ApiError, resolvedPath?: string) => any>wrapCb(cb, 2);\n\t\ttry {\n\t\t\tpath = normalizePath(path);\n\t\t\tassertRoot(this.root).realpath(path, cache, this.cred, newCb);\n\t\t} catch (e) {\n\t\t\tnewCb(e);\n\t\t}\n\t}\n\n\t/**\n\t * Synchronous `realpath`.\n\t * @param path\n\t * @param cache An object literal of mapped paths that can be used to\n\t *   force a specific path resolution or avoid additional `fs.stat` calls for\n\t *   known real paths.\n\t * @return [String]\n\t */\n\tpublic realpathSync(path: string, cache: { [path: string]: string } = {}): string {\n\t\tpath = normalizePath(path);\n\t\treturn assertRoot(this.root).realpathSync(path, cache, this.cred);\n\t}\n\n\tpublic watchFile(filename: string, listener: (curr: Stats, prev: Stats) => void): void;\n\tpublic watchFile(filename: string, options: { persistent?: boolean; interval?: number }, listener: (curr: Stats, prev: Stats) => void): void;\n\tpublic watchFile(filename: string, arg2: any, listener: (curr: Stats, prev: Stats) => void = nopCb): void {\n\t\tthrow new ApiError(ErrorCode.ENOTSUP);\n\t}\n\n\tpublic unwatchFile(filename: string, listener: (curr: Stats, prev: Stats) => void = nopCb): void {\n\t\tthrow new ApiError(ErrorCode.ENOTSUP);\n\t}\n\n\tpublic watch(filename: string, listener?: (event: string, filename: string) => any): _fs.FSWatcher;\n\tpublic watch(filename: string, options: { persistent?: boolean }, listener?: (event: string, filename: string) => any): _fs.FSWatcher;\n\tpublic watch(filename: string, arg2: any, listener: (event: string, filename: string) => any = nopCb): _fs.FSWatcher {\n\t\tthrow new ApiError(ErrorCode.ENOTSUP);\n\t}\n\n\t/**\n\t * Asynchronous `access`.\n\t * @param path\n\t * @param mode\n\t * @param callback\n\t */\n\tpublic access(path: string, callback: (err: ApiError) => void): void;\n\tpublic access(path: string, mode: number, callback: (err: ApiError) => void): void;\n\tpublic access(path: string, arg2: any, callback: (e: ApiError) => void = nopCb): void {\n\t\tconst mode = typeof arg2 === 'number' ? arg2 : FilePerm.READ;\n\t\tcallback = typeof arg2 === 'function' ? arg2 : nopCb;\n\t\tconst newCb = <(err: ApiError, resolvedPath?: string) => any>wrapCb(callback, 2);\n\t\ttry {\n\t\t\tpath = normalizePath(path);\n\t\t\tassertRoot(this.root).access(path, mode, this.cred, newCb);\n\t\t} catch (e) {\n\t\t\tnewCb(e);\n\t\t}\n\t}\n\n\t/**\n\t * Synchronous `access`.\n\t * @param path\n\t * @param mode\n\t */\n\tpublic accessSync(path: string, mode: number = 0o600): void {\n\t\tpath = normalizePath(path);\n\t\treturn assertRoot(this.root).accessSync(path, mode, this.cred);\n\t}\n\n\tpublic createReadStream(\n\t\tpath: string,\n\t\toptions?: {\n\t\t\tflags?: string;\n\t\t\tencoding?: string;\n\t\t\tfd?: number;\n\t\t\tmode?: number;\n\t\t\tautoClose?: boolean;\n\t\t}\n\t): _fs.ReadStream {\n\t\tthrow new ApiError(ErrorCode.ENOTSUP);\n\t}\n\n\tpublic createWriteStream(\n\t\tpath: string,\n\t\toptions?: {\n\t\t\tflags?: string;\n\t\t\tencoding?: string;\n\t\t\tfd?: number;\n\t\t\tmode?: number;\n\t\t}\n\t): _fs.WriteStream {\n\t\tthrow new ApiError(ErrorCode.ENOTSUP);\n\t}\n\n\t/**\n\t * For unit testing. Passes all incoming callbacks to cbWrapper for wrapping.\n\t */\n\tpublic wrapCallbacks(cbWrapper: (cb: Function, args: number) => Function) {\n\t\twrapCbHook = <any>cbWrapper;\n\t}\n\n\tprivate getFdForFile(file: File): number {\n\t\tconst fd = this.nextFd++;\n\t\tthis.fdMap[fd] = file;\n\t\treturn fd;\n\t}\n\tprivate fd2file(fd: number): File {\n\t\tconst rv = this.fdMap[fd];\n\t\tif (rv) {\n\t\t\treturn rv;\n\t\t} else {\n\t\t\tthrow new ApiError(ErrorCode.EBADF, 'Invalid file descriptor.');\n\t\t}\n\t}\n\tprivate closeFd(fd: number): void {\n\t\tdelete this.fdMap[fd];\n\t}\n}\n\nexport interface FSModule extends FS {\n\t/**\n\t * The FS constructor.\n\t */\n\tFS: typeof FS;\n\t/**\n\t * The FS.Stats constructor.\n\t */\n\tStats: typeof Stats;\n\t/**\n\t * Retrieve the FS object backing the fs module.\n\t */\n\tgetFSModule(): FS;\n\t/**\n\t * Set the FS object backing the fs module.\n\t */\n\tchangeFSModule(newFs: FS): void;\n}\n"]}