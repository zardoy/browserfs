{"version":3,"file":"file_system.js","sourceRoot":"","sources":["../../../src/core/file_system.ts"],"names":[],"mappings":"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","sourcesContent":["/* eslint-disable @typescript-eslint/no-unused-vars */\n// disable no-unused-vars since BaseFileSystem uses them a lot\n\nimport { ApiError, ErrorCode } from './api_error';\nimport Stats from './stats';\nimport { File } from './file';\nimport { FileFlag, ActionType } from './file_flag';\nimport * as path from 'path';\nimport { fail } from './util';\nimport Cred from './cred';\nimport { Buffer } from 'buffer';\n\nexport type BFSOneArgCallback = (e?: ApiError | null) => any;\nexport type BFSCallback<T> = (e: ApiError | null | undefined, rv?: T) => any;\nexport type BFSThreeArgCallback<T, U> = (e: ApiError | null | undefined, arg1?: T, arg2?: U) => any;\n\n/**\n * Interface for a filesystem. **All** BrowserFS FileSystems should implement\n * this interface.\n *\n * Below, we denote each API method as **Core**, **Supplemental**, or\n * **Optional**.\n *\n * ### Core Methods\n *\n * **Core** API methods *need* to be implemented for basic read/write\n * functionality.\n *\n * Note that read-only FileSystems can choose to not implement core methods\n * that mutate files or metadata. The default implementation will pass a\n * NOT_SUPPORTED error to the callback.\n *\n * ### Supplemental Methods\n *\n * **Supplemental** API methods do not need to be implemented by a filesystem.\n * The default implementation implements all of the supplemental API methods in\n * terms of the **core** API methods.\n *\n * Note that a file system may choose to implement supplemental methods for\n * efficiency reasons.\n *\n * The code for some supplemental methods was adapted directly from NodeJS's\n * fs.js source code.\n *\n * ### Optional Methods\n *\n * **Optional** API methods provide functionality that may not be available in\n * all filesystems. For example, all symlink/hardlink-related API methods fall\n * under this category.\n *\n * The default implementation will pass a NOT_SUPPORTED error to the callback.\n *\n * ### Argument Assumptions\n *\n * You can assume the following about arguments passed to each API method:\n *\n * * **Every path is an absolute path.** Meaning, `.`, `..`, and other items\n *   are resolved into an absolute form.\n * * **All arguments are present.** Any optional arguments at the Node API level\n *   have been passed in with their default values.\n * * **The callback will reset the stack depth.** When your filesystem calls the\n *   callback with the requested information, it will use `setImmediate` to\n *   reset the JavaScript stack depth before calling the user-supplied callback.\n */\nexport interface FileSystem {\n\t/**\n\t * **Optional**: Returns the name of the file system.\n\t */\n\tgetName(): string;\n\t/**\n\t * **Optional**: Passes the following information to the callback:\n\t *\n\t * * Total number of bytes available on this file system.\n\t * * number of free bytes available on this file system.\n\t *\n\t * @todo This info is not available through the Node API. Perhaps we could do a\n\t *   polyfill of diskspace.js, or add a new Node API function.\n\t * @param path The path to the location that is being queried. Only\n\t *   useful for filesystems that support mount points.\n\t */\n\tdiskSpace(p: string, cb: (total: number, free: number) => any): void;\n\t/**\n\t * **Core**: Is this filesystem read-only?\n\t * @return True if this FileSystem is inherently read-only.\n\t */\n\tisReadOnly(): boolean;\n\t/**\n\t * **Core**: Does the filesystem support optional symlink/hardlink-related\n\t *   commands?\n\t * @return True if the FileSystem supports the optional\n\t *   symlink/hardlink-related commands.\n\t */\n\tsupportsLinks(): boolean;\n\t/**\n\t * **Core**: Does the filesystem support optional property-related commands?\n\t * @return True if the FileSystem supports the optional\n\t *   property-related commands (permissions, utimes, etc).\n\t */\n\tsupportsProps(): boolean;\n\t/**\n\t * **Core**: Does the filesystem support the optional synchronous interface?\n\t * @return True if the FileSystem supports synchronous operations.\n\t */\n\tsupportsSynch(): boolean;\n\t// **CORE API METHODS**\n\t// File or directory operations\n\t/**\n\t * **Core**: Asynchronous access.\n\t */\n\taccess(p: string, mode: number, cred: Cred, cb: BFSOneArgCallback): void;\n\t/**\n\t * **Core**: Synchronous access.\n\t */\n\taccessSync(p: string, mode: number, cred: Cred): void;\n\t/**\n\t * **Core**: Asynchronous rename. No arguments other than a possible exception\n\t * are given to the completion callback.\n\t */\n\trename(oldPath: string, newPath: string, cred: Cred, cb: BFSOneArgCallback): void;\n\t/**\n\t * **Core**: Synchronous rename.\n\t */\n\trenameSync(oldPath: string, newPath: string, cred: Cred): void;\n\t/**\n\t * **Core**: Asynchronous `stat` or `lstat`.\n\t * @param isLstat True if this is `lstat`, false if this is regular\n\t *   `stat`.\n\t */\n\tstat(p: string, isLstat: boolean | null, cred: Cred, cb: BFSCallback<Stats>): void;\n\t/**\n\t * **Core**: Synchronous `stat` or `lstat`.\n\t * @param isLstat True if this is `lstat`, false if this is regular\n\t *   `stat`.\n\t */\n\tstatSync(p: string, isLstat: boolean | null, cred: Cred): Stats;\n\t// File operations\n\t/**\n\t * **Core**: Asynchronous file open.\n\t * @see http://www.manpagez.com/man/2/open/\n\t * @param flags Handles the complexity of the various file\n\t *   modes. See its API for more details.\n\t * @param mode Mode to use to open the file. Can be ignored if the\n\t *   filesystem doesn't support permissions.\n\t */\n\topen(p: string, flag: FileFlag, mode: number, cred: Cred, cb: BFSCallback<File>): void;\n\t/**\n\t * **Core**: Synchronous file open.\n\t * @see http://www.manpagez.com/man/2/open/\n\t * @param flags Handles the complexity of the various file\n\t *   modes. See its API for more details.\n\t * @param mode Mode to use to open the file. Can be ignored if the\n\t *   filesystem doesn't support permissions.\n\t */\n\topenSync(p: string, flag: FileFlag, mode: number, cred: Cred): File;\n\t/**\n\t * **Core**: Asynchronous `unlink`.\n\t */\n\tunlink(p: string, cred: Cred, cb: BFSOneArgCallback): void;\n\t/**\n\t * **Core**: Synchronous `unlink`.\n\t */\n\tunlinkSync(p: string, cred: Cred): void;\n\t// Directory operations\n\t/**\n\t * **Core**: Asynchronous `rmdir`.\n\t */\n\trmdir(p: string, cred: Cred, cb: BFSOneArgCallback): void;\n\t/**\n\t * **Core**: Synchronous `rmdir`.\n\t */\n\trmdirSync(p: string, cred: Cred): void;\n\t/**\n\t * **Core**: Asynchronous `mkdir`.\n\t * @param mode Mode to make the directory using. Can be ignored if\n\t *   the filesystem doesn't support permissions.\n\t */\n\tmkdir(p: string, mode: number, cred: Cred, cb: BFSOneArgCallback): void;\n\t/**\n\t * **Core**: Synchronous `mkdir`.\n\t * @param mode Mode to make the directory using. Can be ignored if\n\t *   the filesystem doesn't support permissions.\n\t */\n\tmkdirSync(p: string, mode: number, cred: Cred): void;\n\t/**\n\t * **Core**: Asynchronous `readdir`. Reads the contents of a directory.\n\t *\n\t * The callback gets two arguments `(err, files)` where `files` is an array of\n\t * the names of the files in the directory excluding `'.'` and `'..'`.\n\t */\n\treaddir(p: string, cred: Cred, cb: BFSCallback<string[]>): void;\n\t/**\n\t * **Core**: Synchronous `readdir`. Reads the contents of a directory.\n\t */\n\treaddirSync(p: string, cred: Cred): string[];\n\t// **SUPPLEMENTAL INTERFACE METHODS**\n\t// File or directory operations\n\t/**\n\t * **Supplemental**: Test whether or not the given path exists by checking with\n\t * the file system. Then call the callback argument with either true or false.\n\t */\n\texists(p: string, cred: Cred, cb: (exists: boolean) => void): void;\n\t/**\n\t * **Supplemental**: Test whether or not the given path exists by checking with\n\t * the file system.\n\t */\n\texistsSync(p: string, cred: Cred): boolean;\n\t/**\n\t * **Supplemental**: Asynchronous `realpath`. The callback gets two arguments\n\t * `(err, resolvedPath)`.\n\t *\n\t * Note that the Node API will resolve `path` to an absolute path.\n\t * @param cache An object literal of mapped paths that can be used to\n\t *   force a specific path resolution or avoid additional `fs.stat` calls for\n\t *   known real paths. If not supplied by the user, it'll be an empty object.\n\t */\n\trealpath(p: string, cache: { [path: string]: string }, cred: Cred, cb: BFSCallback<string>): void;\n\t/**\n\t * **Supplemental**: Synchronous `realpath`.\n\t *\n\t * Note that the Node API will resolve `path` to an absolute path.\n\t * @param cache An object literal of mapped paths that can be used to\n\t *   force a specific path resolution or avoid additional `fs.stat` calls for\n\t *   known real paths. If not supplied by the user, it'll be an empty object.\n\t */\n\trealpathSync(p: string, cache: { [path: string]: string }, cred: Cred): string;\n\t// File operations\n\t/**\n\t * **Supplemental**: Asynchronous `truncate`.\n\t */\n\ttruncate(p: string, len: number, cred: Cred, cb: BFSOneArgCallback): void;\n\t/**\n\t * **Supplemental**: Synchronous `truncate`.\n\t */\n\ttruncateSync(p: string, len: number, cred: Cred): void;\n\t/**\n\t * **Supplemental**: Asynchronously reads the entire contents of a file.\n\t * @param encoding If non-null, the file's contents should be decoded\n\t *   into a string using that encoding. Otherwise, if encoding is null, fetch\n\t *   the file's contents as a Buffer.\n\t * @param cb If no encoding is specified, then the raw buffer is returned.\n\t */\n\treadFile(fname: string, encoding: string | null, flag: FileFlag, cred: Cred, cb: BFSCallback<string | Buffer>): void;\n\t/**\n\t * **Supplemental**: Synchronously reads the entire contents of a file.\n\t * @param encoding If non-null, the file's contents should be decoded\n\t *   into a string using that encoding. Otherwise, if encoding is null, fetch\n\t *   the file's contents as a Buffer.\n\t */\n\treadFileSync(fname: string, encoding: string | null, flag: FileFlag, cred: Cred): any;\n\t/**\n\t * **Supplemental**: Asynchronously writes data to a file, replacing the file\n\t * if it already exists.\n\t *\n\t * The encoding option is ignored if data is a buffer.\n\t */\n\twriteFile(fname: string, data: any, encoding: string | null, flag: FileFlag, mode: number, cred: Cred, cb: BFSOneArgCallback): void;\n\t/**\n\t * **Supplemental**: Synchronously writes data to a file, replacing the file\n\t * if it already exists.\n\t *\n\t * The encoding option is ignored if data is a buffer.\n\t */\n\twriteFileSync(fname: string, data: string | Buffer, encoding: string | null, flag: FileFlag, mode: number, cred: Cred): void;\n\t/**\n\t * **Supplemental**: Asynchronously append data to a file, creating the file if\n\t * it not yet exists.\n\t */\n\tappendFile(fname: string, data: string | Buffer, encoding: string | null, flag: FileFlag, mode: number, cred: Cred, cb: BFSOneArgCallback): void;\n\t/**\n\t * **Supplemental**: Synchronously append data to a file, creating the file if\n\t * it not yet exists.\n\t */\n\tappendFileSync(fname: string, data: string | Buffer, encoding: string | null, flag: FileFlag, mode: number, cred: Cred): void;\n\t// **OPTIONAL INTERFACE METHODS**\n\t// Property operations\n\t// This isn't always possible on some filesystem types (e.g. Dropbox).\n\t/**\n\t * **Optional**: Asynchronous `chmod` or `lchmod`.\n\t * @param isLchmod `True` if `lchmod`, false if `chmod`. Has no\n\t *   bearing on result if links aren't supported.\n\t */\n\tchmod(p: string, isLchmod: boolean, mode: number, cred: Cred, cb: BFSOneArgCallback): void;\n\t/**\n\t * **Optional**: Synchronous `chmod` or `lchmod`.\n\t * @param isLchmod `True` if `lchmod`, false if `chmod`. Has no\n\t *   bearing on result if links aren't supported.\n\t */\n\tchmodSync(p: string, isLchmod: boolean, mode: number, cred: Cred): void;\n\t/**\n\t * **Optional**: Asynchronous `chown` or `lchown`.\n\t * @param isLchown `True` if `lchown`, false if `chown`. Has no\n\t *   bearing on result if links aren't supported.\n\t */\n\tchown(p: string, isLchown: boolean, new_uid: number, new_gid: number, cred: Cred, cb: BFSOneArgCallback): void;\n\t/**\n\t * **Optional**: Synchronous `chown` or `lchown`.\n\t * @param isLchown `True` if `lchown`, false if `chown`. Has no\n\t *   bearing on result if links aren't supported.\n\t */\n\tchownSync(p: string, isLchown: boolean, new_uid: number, new_gid: number, cred: Cred): void;\n\t/**\n\t * **Optional**: Change file timestamps of the file referenced by the supplied\n\t * path.\n\t */\n\tutimes(p: string, atime: Date, mtime: Date, cred: Cred, cb: BFSOneArgCallback): void;\n\t/**\n\t * **Optional**: Change file timestamps of the file referenced by the supplied\n\t * path.\n\t */\n\tutimesSync(p: string, atime: Date, mtime: Date, cred: Cred): void;\n\t// Symlink operations\n\t// Symlinks aren't always supported.\n\t/**\n\t * **Optional**: Asynchronous `link`.\n\t */\n\tlink(srcpath: string, dstpath: string, cred: Cred, cb: BFSOneArgCallback): void;\n\t/**\n\t * **Optional**: Synchronous `link`.\n\t */\n\tlinkSync(srcpath: string, dstpath: string, cred: Cred): void;\n\t/**\n\t * **Optional**: Asynchronous `symlink`.\n\t * @param type can be either `'dir'` or `'file'`\n\t */\n\tsymlink(srcpath: string, dstpath: string, type: string, cred: Cred, cb: BFSOneArgCallback): void;\n\t/**\n\t * **Optional**: Synchronous `symlink`.\n\t * @param type can be either `'dir'` or `'file'`\n\t */\n\tsymlinkSync(srcpath: string, dstpath: string, type: string, cred: Cred): void;\n\t/**\n\t * **Optional**: Asynchronous readlink.\n\t */\n\treadlink(p: string, cred: Cred, cb: BFSCallback<string>): void;\n\t/**\n\t * **Optional**: Synchronous readlink.\n\t */\n\treadlinkSync(p: string, cred: Cred): string;\n}\n\n/**\n * Describes a file system option.\n */\nexport interface FileSystemOption<T> {\n\t// The basic JavaScript type(s) for this option.\n\ttype: string | string[];\n\t// Whether or not the option is optional (e.g., can be set to null or undefined).\n\t// Defaults to `false`.\n\toptional?: boolean;\n\t// Description of the option. Used in error messages and documentation.\n\tdescription: string;\n\t// A custom validation function to check if the option is valid.\n\t// Calls the callback with an error object on an error.\n\t// (Can call callback synchronously.)\n\t// Defaults to `(opt, cb) => cb()`.\n\tvalidator?(opt: T, cb: BFSOneArgCallback): void;\n}\n\n/**\n * Describes all of the options available in a file system.\n */\nexport interface FileSystemOptions {\n\t[name: string]: FileSystemOption<any>;\n}\n\n/**\n * Contains typings for static functions on the file system constructor.\n */\nexport interface FileSystemConstructor {\n\t/**\n\t * **Core**: Name to identify this particular file system.\n\t */\n\tName: string;\n\t/**\n\t * **Core**: Describes all of the options available for this file system.\n\t */\n\tOptions: FileSystemOptions;\n\t/**\n\t * **Core**: Creates a file system of this given type with the given\n\t * options, and returns the result in a callback.\n\t */\n\tCreate(options: object, cb: BFSCallback<FileSystem>): void;\n\t/**\n\t * **Core**: Creates a file system of this given type with the given\n\t * options, and returns the result in a promise.\n\t */\n\tCreateAsync(options: object): Promise<FileSystem>;\n\t/**\n\t * **Core**: Returns 'true' if this filesystem is available in the current\n\t * environment. For example, a `localStorage`-backed filesystem will return\n\t * 'false' if the browser does not support that API.\n\t *\n\t * Defaults to 'false', as the FileSystem base class isn't usable alone.\n\t */\n\tisAvailable(): boolean;\n}\n\n/**\n * Basic filesystem class. Most filesystems should extend this class, as it\n * provides default implementations for a handful of methods.\n */\nexport class BaseFileSystem {\n\tpublic supportsLinks(): boolean {\n\t\treturn false;\n\t}\n\tpublic diskSpace(p: string, cb: (total: number, free: number) => any): void {\n\t\tcb(0, 0);\n\t}\n\t/**\n\t * Opens the file at path p with the given flag. The file must exist.\n\t * @param p The path to open.\n\t * @param flag The flag to use when opening the file.\n\t */\n\tpublic openFile(p: string, flag: FileFlag, cred: Cred, cb: BFSCallback<File>): void {\n\t\tthrow new ApiError(ErrorCode.ENOTSUP);\n\t}\n\t/**\n\t * Create the file at path p with the given mode. Then, open it with the given\n\t * flag.\n\t */\n\tpublic createFile(p: string, flag: FileFlag, mode: number, cred: Cred, cb: BFSCallback<File>): void {\n\t\tthrow new ApiError(ErrorCode.ENOTSUP);\n\t}\n\tpublic open(p: string, flag: FileFlag, mode: number, cred: Cred, cb: BFSCallback<File>): void {\n\t\tconst mustBeFile = (e: ApiError, stats?: Stats): void => {\n\t\t\tif (e) {\n\t\t\t\t// File does not exist.\n\t\t\t\tswitch (flag.pathNotExistsAction()) {\n\t\t\t\t\tcase ActionType.CREATE_FILE:\n\t\t\t\t\t\t// Ensure parent exists.\n\t\t\t\t\t\treturn this.stat(path.dirname(p), false, cred, (e: ApiError, parentStats?: Stats) => {\n\t\t\t\t\t\t\tif (e) {\n\t\t\t\t\t\t\t\tcb(e);\n\t\t\t\t\t\t\t} else if (parentStats && !parentStats.isDirectory()) {\n\t\t\t\t\t\t\t\tcb(ApiError.ENOTDIR(path.dirname(p)));\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tthis.createFile(p, flag, mode, cred, cb);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\tcase ActionType.THROW_EXCEPTION:\n\t\t\t\t\t\treturn cb(ApiError.ENOENT(p));\n\t\t\t\t\tdefault:\n\t\t\t\t\t\treturn cb(new ApiError(ErrorCode.EINVAL, 'Invalid FileFlag object.'));\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// File exists.\n\t\t\t\tswitch (flag.pathExistsAction()) {\n\t\t\t\t\tcase ActionType.THROW_EXCEPTION:\n\t\t\t\t\t\treturn cb(ApiError.EEXIST(p));\n\t\t\t\t\tcase ActionType.TRUNCATE_FILE:\n\t\t\t\t\t\t// NOTE: In a previous implementation, we deleted the file and\n\t\t\t\t\t\t// re-created it. However, this created a race condition if another\n\t\t\t\t\t\t// asynchronous request was trying to read the file, as the file\n\t\t\t\t\t\t// would not exist for a small period of time.\n\t\t\t\t\t\treturn this.openFile(p, flag, cred, (e: ApiError, fd?: File): void => {\n\t\t\t\t\t\t\tif (e) {\n\t\t\t\t\t\t\t\tcb(e);\n\t\t\t\t\t\t\t} else if (fd) {\n\t\t\t\t\t\t\t\tfd.truncate(0, () => {\n\t\t\t\t\t\t\t\t\tfd.sync(() => {\n\t\t\t\t\t\t\t\t\t\tcb(null, fd);\n\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tfail();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\tcase ActionType.NOP:\n\t\t\t\t\t\treturn this.openFile(p, flag, cred, cb);\n\t\t\t\t\tdefault:\n\t\t\t\t\t\treturn cb(new ApiError(ErrorCode.EINVAL, 'Invalid FileFlag object.'));\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\tthis.stat(p, false, cred, mustBeFile);\n\t}\n\tpublic access(p: string, mode: number, cred: Cred, cb: BFSOneArgCallback): void {\n\t\tcb(new ApiError(ErrorCode.ENOTSUP));\n\t}\n\tpublic accessSync(p: string, mode: number, cred: Cred): void {\n\t\tthrow new ApiError(ErrorCode.ENOTSUP);\n\t}\n\tpublic rename(oldPath: string, newPath: string, cred: Cred, cb: BFSOneArgCallback): void {\n\t\tcb(new ApiError(ErrorCode.ENOTSUP));\n\t}\n\tpublic renameSync(oldPath: string, newPath: string, cred: Cred): void {\n\t\tthrow new ApiError(ErrorCode.ENOTSUP);\n\t}\n\tpublic stat(p: string, isLstat: boolean | null, cred: Cred, cb: BFSCallback<Stats>): void {\n\t\tcb(new ApiError(ErrorCode.ENOTSUP));\n\t}\n\tpublic statSync(p: string, isLstat: boolean | null, cred: Cred): Stats {\n\t\tthrow new ApiError(ErrorCode.ENOTSUP);\n\t}\n\t/**\n\t * Opens the file at path p with the given flag. The file must exist.\n\t * @param p The path to open.\n\t * @param flag The flag to use when opening the file.\n\t * @return A File object corresponding to the opened file.\n\t */\n\tpublic openFileSync(p: string, flag: FileFlag, cred: Cred): File {\n\t\tthrow new ApiError(ErrorCode.ENOTSUP);\n\t}\n\t/**\n\t * Create the file at path p with the given mode. Then, open it with the given\n\t * flag.\n\t */\n\tpublic createFileSync(p: string, flag: FileFlag, mode: number, cred: Cred): File {\n\t\tthrow new ApiError(ErrorCode.ENOTSUP);\n\t}\n\tpublic openSync(p: string, flag: FileFlag, mode: number, cred: Cred): File {\n\t\t// Check if the path exists, and is a file.\n\t\tlet stats: Stats;\n\t\ttry {\n\t\t\tstats = this.statSync(p, false, cred);\n\t\t} catch (e) {\n\t\t\t// File does not exist.\n\t\t\tswitch (flag.pathNotExistsAction()) {\n\t\t\t\tcase ActionType.CREATE_FILE:\n\t\t\t\t\t// Ensure parent exists.\n\t\t\t\t\tconst parentStats = this.statSync(path.dirname(p), false, cred);\n\t\t\t\t\tif (!parentStats.isDirectory()) {\n\t\t\t\t\t\tthrow ApiError.ENOTDIR(path.dirname(p));\n\t\t\t\t\t}\n\t\t\t\t\treturn this.createFileSync(p, flag, mode, cred);\n\t\t\t\tcase ActionType.THROW_EXCEPTION:\n\t\t\t\t\tthrow ApiError.ENOENT(p);\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new ApiError(ErrorCode.EINVAL, 'Invalid FileFlag object.');\n\t\t\t}\n\t\t}\n\t\tif (!stats.hasAccess(mode, cred)) {\n\t\t\tthrow ApiError.EACCES(p);\n\t\t}\n\n\t\t// File exists.\n\t\tswitch (flag.pathExistsAction()) {\n\t\t\tcase ActionType.THROW_EXCEPTION:\n\t\t\t\tthrow ApiError.EEXIST(p);\n\t\t\tcase ActionType.TRUNCATE_FILE:\n\t\t\t\t// Delete file.\n\t\t\t\tthis.unlinkSync(p, cred);\n\t\t\t\t// Create file. Use the same mode as the old file.\n\t\t\t\t// Node itself modifies the ctime when this occurs, so this action\n\t\t\t\t// will preserve that behavior if the underlying file system\n\t\t\t\t// supports those properties.\n\t\t\t\treturn this.createFileSync(p, flag, stats.mode, cred);\n\t\t\tcase ActionType.NOP:\n\t\t\t\treturn this.openFileSync(p, flag, cred);\n\t\t\tdefault:\n\t\t\t\tthrow new ApiError(ErrorCode.EINVAL, 'Invalid FileFlag object.');\n\t\t}\n\t}\n\tpublic unlink(p: string, cred: Cred, cb: BFSOneArgCallback): void {\n\t\tcb(new ApiError(ErrorCode.ENOTSUP));\n\t}\n\tpublic unlinkSync(p: string, cred: Cred): void {\n\t\tthrow new ApiError(ErrorCode.ENOTSUP);\n\t}\n\tpublic rmdir(p: string, cred: Cred, cb: BFSOneArgCallback): void {\n\t\tcb(new ApiError(ErrorCode.ENOTSUP));\n\t}\n\tpublic rmdirSync(p: string, cred: Cred): void {\n\t\tthrow new ApiError(ErrorCode.ENOTSUP);\n\t}\n\tpublic mkdir(p: string, mode: number, cred: Cred, cb: BFSOneArgCallback): void {\n\t\tcb(new ApiError(ErrorCode.ENOTSUP));\n\t}\n\tpublic mkdirSync(p: string, mode: number, cred: Cred): void {\n\t\tthrow new ApiError(ErrorCode.ENOTSUP);\n\t}\n\tpublic readdir(p: string, cred: Cred, cb: BFSCallback<string[]>): void {\n\t\tcb(new ApiError(ErrorCode.ENOTSUP));\n\t}\n\tpublic readdirSync(p: string, cred: Cred): string[] {\n\t\tthrow new ApiError(ErrorCode.ENOTSUP);\n\t}\n\tpublic exists(p: string, cred: Cred, cb: (exists: boolean) => void): void {\n\t\tthis.stat(p, null, cred, function (err) {\n\t\t\tcb(!err);\n\t\t});\n\t}\n\tpublic existsSync(p: string, cred: Cred): boolean {\n\t\ttry {\n\t\t\tthis.statSync(p, true, cred);\n\t\t\treturn true;\n\t\t} catch (e) {\n\t\t\treturn false;\n\t\t}\n\t}\n\tpublic realpath(p: string, cache: { [path: string]: string }, cred: Cred, cb: BFSCallback<string>): void {\n\t\tif (this.supportsLinks()) {\n\t\t\t// The path could contain symlinks. Split up the path,\n\t\t\t// resolve any symlinks, return the resolved string.\n\t\t\tconst splitPath = p.split(path.sep);\n\t\t\t// TODO: Simpler to just pass through file, find sep and such.\n\t\t\tfor (let i = 0; i < splitPath.length; i++) {\n\t\t\t\tconst addPaths = splitPath.slice(0, i + 1);\n\t\t\t\tsplitPath[i] = path.join.apply(null, addPaths);\n\t\t\t}\n\t\t} else {\n\t\t\t// No symlinks. We just need to verify that it exists.\n\t\t\tthis.exists(p, cred, function (doesExist) {\n\t\t\t\tif (doesExist) {\n\t\t\t\t\tcb(null, p);\n\t\t\t\t} else {\n\t\t\t\t\tcb(ApiError.ENOENT(p));\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t}\n\tpublic realpathSync(p: string, cache: { [path: string]: string }, cred: Cred): string {\n\t\tif (this.supportsLinks()) {\n\t\t\t// The path could contain symlinks. Split up the path,\n\t\t\t// resolve any symlinks, return the resolved string.\n\t\t\tconst splitPath = p.split(path.sep);\n\t\t\t// TODO: Simpler to just pass through file, find sep and such.\n\t\t\tfor (let i = 0; i < splitPath.length; i++) {\n\t\t\t\tconst addPaths = splitPath.slice(0, i + 1);\n\t\t\t\tsplitPath[i] = path.join.apply(path, addPaths);\n\t\t\t}\n\t\t\treturn splitPath.join(path.sep);\n\t\t} else {\n\t\t\t// No symlinks. We just need to verify that it exists.\n\t\t\tif (this.existsSync(p, cred)) {\n\t\t\t\treturn p;\n\t\t\t} else {\n\t\t\t\tthrow ApiError.ENOENT(p);\n\t\t\t}\n\t\t}\n\t}\n\tpublic truncate(p: string, len: number, cred: Cred, cb: BFSOneArgCallback): void {\n\t\tthis.open(p, FileFlag.getFileFlag('r+'), 0x1a4, cred, function (er: ApiError, fd?: File) {\n\t\t\tif (er) {\n\t\t\t\treturn cb(er);\n\t\t\t}\n\t\t\tfd!.truncate(len, function (er: any) {\n\t\t\t\tfd!.close(function (er2: any) {\n\t\t\t\t\tcb(er || er2);\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\t}\n\tpublic truncateSync(p: string, len: number, cred: Cred): void {\n\t\tconst fd = this.openSync(p, FileFlag.getFileFlag('r+'), 0x1a4, cred);\n\t\t// Need to safely close FD, regardless of whether or not truncate succeeds.\n\t\ttry {\n\t\t\tfd.truncateSync(len);\n\t\t} finally {\n\t\t\tfd.closeSync();\n\t\t}\n\t}\n\tpublic readFile(fname: string, encoding: BufferEncoding | null, flag: FileFlag, cred: Cred, cb: BFSCallback<string | Buffer>): void {\n\t\t// Wrap cb in file closing code.\n\t\tconst oldCb = cb;\n\t\t// Get file.\n\t\tthis.open(fname, flag, 0x1a4, cred, (err, fd) => {\n\t\t\tif (err) {\n\t\t\t\treturn cb(err);\n\t\t\t}\n\t\t\tcb = function (err?: ApiError | null, arg?: string | Buffer) {\n\t\t\t\tfd!.close(function (err2: any) {\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\terr = err2;\n\t\t\t\t\t}\n\t\t\t\t\treturn oldCb(err, arg);\n\t\t\t\t});\n\t\t\t};\n\t\t\tfd!.stat((err, stat?) => {\n\t\t\t\tif (err) {\n\t\t\t\t\treturn cb(err);\n\t\t\t\t}\n\t\t\t\t// Allocate buffer.\n\t\t\t\tconst buf = Buffer.alloc(stat!.size);\n\t\t\t\tfd!.read(buf, 0, stat!.size, 0, (err?: ApiError | null) => {\n\t\t\t\t\tif (err) {\n\t\t\t\t\t\treturn cb(err);\n\t\t\t\t\t} else if (encoding === null) {\n\t\t\t\t\t\treturn cb(err, buf);\n\t\t\t\t\t}\n\t\t\t\t\ttry {\n\t\t\t\t\t\tcb(null, buf.toString(encoding));\n\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\tcb(e);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\t}\n\tpublic readFileSync(fname: string, encoding: BufferEncoding | null, flag: FileFlag, cred: Cred): any {\n\t\t// Get file.\n\t\tconst fd = this.openSync(fname, flag, 0x1a4, cred);\n\t\ttry {\n\t\t\tconst stat = fd.statSync();\n\t\t\t// Allocate buffer.\n\t\t\tconst buf = Buffer.alloc(stat.size);\n\t\t\tfd.readSync(buf, 0, stat.size, 0);\n\t\t\tfd.closeSync();\n\t\t\tif (encoding === null) {\n\t\t\t\treturn buf;\n\t\t\t}\n\t\t\treturn buf.toString(encoding);\n\t\t} finally {\n\t\t\tfd.closeSync();\n\t\t}\n\t}\n\tpublic writeFile(fname: string, data: any, encoding: BufferEncoding | null, flag: FileFlag, mode: number, cred: Cred, cb: BFSOneArgCallback): void {\n\t\t// Wrap cb in file closing code.\n\t\tconst oldCb = cb;\n\t\t// Get file.\n\t\tthis.open(fname, flag, 0x1a4, cred, function (err: ApiError, fd?: File) {\n\t\t\tif (err) {\n\t\t\t\treturn cb(err);\n\t\t\t}\n\t\t\tcb = function (err: ApiError) {\n\t\t\t\tfd!.close(function (err2: any) {\n\t\t\t\t\toldCb(err ? err : err2);\n\t\t\t\t});\n\t\t\t};\n\n\t\t\ttry {\n\t\t\t\tif (typeof data === 'string') {\n\t\t\t\t\tdata = Buffer.from(data, encoding!);\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\treturn cb(e);\n\t\t\t}\n\t\t\t// Write into file.\n\t\t\tfd!.write(data, 0, data.length, 0, cb);\n\t\t});\n\t}\n\tpublic writeFileSync(fname: string, data: any, encoding: BufferEncoding | null, flag: FileFlag, mode: number, cred: Cred): void {\n\t\t// Get file.\n\t\tconst fd = this.openSync(fname, flag, mode, cred);\n\t\ttry {\n\t\t\tif (typeof data === 'string') {\n\t\t\t\tdata = Buffer.from(data, encoding!);\n\t\t\t}\n\t\t\t// Write into file.\n\t\t\tfd.writeSync(data, 0, data.length, 0);\n\t\t} finally {\n\t\t\tfd.closeSync();\n\t\t}\n\t}\n\tpublic appendFile(fname: string, data: any, encoding: BufferEncoding | null, flag: FileFlag, mode: number, cred: Cred, cb: BFSOneArgCallback): void {\n\t\t// Wrap cb in file closing code.\n\t\tconst oldCb = cb;\n\t\tthis.open(fname, flag, mode, cred, function (err: ApiError, fd?: File) {\n\t\t\tif (err) {\n\t\t\t\treturn cb(err);\n\t\t\t}\n\t\t\tcb = function (err: ApiError) {\n\t\t\t\tfd!.close(function (err2: any) {\n\t\t\t\t\toldCb(err ? err : err2);\n\t\t\t\t});\n\t\t\t};\n\t\t\tif (typeof data === 'string') {\n\t\t\t\tdata = Buffer.from(data, encoding!);\n\t\t\t}\n\t\t\tfd!.write(data, 0, data.length, null, cb);\n\t\t});\n\t}\n\tpublic appendFileSync(fname: string, data: any, encoding: BufferEncoding | null, flag: FileFlag, mode: number, cred: Cred): void {\n\t\tconst fd = this.openSync(fname, flag, mode, cred);\n\t\ttry {\n\t\t\tif (typeof data === 'string') {\n\t\t\t\tdata = Buffer.from(data, encoding!);\n\t\t\t}\n\t\t\tfd.writeSync(data, 0, data.length, null);\n\t\t} finally {\n\t\t\tfd.closeSync();\n\t\t}\n\t}\n\tpublic chmod(p: string, isLchmod: boolean, mode: number, cred: Cred, cb: BFSOneArgCallback): void {\n\t\tcb(new ApiError(ErrorCode.ENOTSUP));\n\t}\n\tpublic chmodSync(p: string, isLchmod: boolean, mode: number, cred: Cred) {\n\t\tthrow new ApiError(ErrorCode.ENOTSUP);\n\t}\n\tpublic chown(p: string, isLchown: boolean, new_uid: number, new_gid: number, cred: Cred, cb: BFSOneArgCallback): void {\n\t\tcb(new ApiError(ErrorCode.ENOTSUP));\n\t}\n\tpublic chownSync(p: string, isLchown: boolean, new_uid: number, new_gid: number, cred: Cred): void {\n\t\tthrow new ApiError(ErrorCode.ENOTSUP);\n\t}\n\tpublic utimes(p: string, atime: Date, mtime: Date, cred: Cred, cb: BFSOneArgCallback): void {\n\t\tcb(new ApiError(ErrorCode.ENOTSUP));\n\t}\n\tpublic utimesSync(p: string, atime: Date, mtime: Date, cred: Cred): void {\n\t\tthrow new ApiError(ErrorCode.ENOTSUP);\n\t}\n\tpublic link(srcpath: string, dstpath: string, cred: Cred, cb: BFSOneArgCallback): void {\n\t\tcb(new ApiError(ErrorCode.ENOTSUP));\n\t}\n\tpublic linkSync(srcpath: string, dstpath: string, cred: Cred): void {\n\t\tthrow new ApiError(ErrorCode.ENOTSUP);\n\t}\n\tpublic symlink(srcpath: string, dstpath: string, type: string, cred: Cred, cb: BFSOneArgCallback): void {\n\t\tcb(new ApiError(ErrorCode.ENOTSUP));\n\t}\n\tpublic symlinkSync(srcpath: string, dstpath: string, type: string, cred: Cred): void {\n\t\tthrow new ApiError(ErrorCode.ENOTSUP);\n\t}\n\tpublic readlink(p: string, cred: Cred, cb: BFSOneArgCallback): void {\n\t\tcb(new ApiError(ErrorCode.ENOTSUP));\n\t}\n\tpublic readlinkSync(p: string, cred: Cred): string {\n\t\tthrow new ApiError(ErrorCode.ENOTSUP);\n\t}\n}\n\n/**\n * Implements the asynchronous API in terms of the synchronous API.\n * @class SynchronousFileSystem\n */\nexport class SynchronousFileSystem extends BaseFileSystem {\n\tpublic supportsSynch(): boolean {\n\t\treturn true;\n\t}\n\n\tpublic access(p: string, mode: number, cred: Cred, cb: BFSOneArgCallback): void {\n\t\ttry {\n\t\t\tthis.accessSync(p, mode, cred);\n\t\t\tcb();\n\t\t} catch (e) {\n\t\t\tcb(e);\n\t\t}\n\t}\n\n\tpublic rename(oldPath: string, newPath: string, cred: Cred, cb: BFSOneArgCallback): void {\n\t\ttry {\n\t\t\tthis.renameSync(oldPath, newPath, cred);\n\t\t\tcb();\n\t\t} catch (e) {\n\t\t\tcb(e);\n\t\t}\n\t}\n\n\tpublic stat(p: string, isLstat: boolean | null, cred: Cred, cb: BFSCallback<Stats>): void {\n\t\ttry {\n\t\t\tcb(null, this.statSync(p, isLstat, cred));\n\t\t} catch (e) {\n\t\t\tcb(e);\n\t\t}\n\t}\n\n\tpublic open(p: string, flags: FileFlag, mode: number, cred: Cred, cb: BFSCallback<File>): void {\n\t\ttry {\n\t\t\tcb(null, this.openSync(p, flags, mode, cred));\n\t\t} catch (e) {\n\t\t\tcb(e);\n\t\t}\n\t}\n\n\tpublic unlink(p: string, cred: Cred, cb: BFSOneArgCallback): void {\n\t\ttry {\n\t\t\tthis.unlinkSync(p, cred);\n\t\t\tcb();\n\t\t} catch (e) {\n\t\t\tcb(e);\n\t\t}\n\t}\n\n\tpublic rmdir(p: string, cred: Cred, cb: BFSOneArgCallback): void {\n\t\ttry {\n\t\t\tthis.rmdirSync(p, cred);\n\t\t\tcb();\n\t\t} catch (e) {\n\t\t\tcb(e);\n\t\t}\n\t}\n\n\tpublic mkdir(p: string, mode: number, cred: Cred, cb: BFSOneArgCallback): void {\n\t\ttry {\n\t\t\tthis.mkdirSync(p, mode, cred);\n\t\t\tcb();\n\t\t} catch (e) {\n\t\t\tcb(e);\n\t\t}\n\t}\n\n\tpublic readdir(p: string, cred: Cred, cb: BFSCallback<string[]>): void {\n\t\ttry {\n\t\t\tcb(null, this.readdirSync(p, cred));\n\t\t} catch (e) {\n\t\t\tcb(e);\n\t\t}\n\t}\n\n\tpublic chmod(p: string, isLchmod: boolean, mode: number, cred: Cred, cb: BFSOneArgCallback): void {\n\t\ttry {\n\t\t\tthis.chmodSync(p, isLchmod, mode, cred);\n\t\t\tcb();\n\t\t} catch (e) {\n\t\t\tcb(e);\n\t\t}\n\t}\n\n\tpublic chown(p: string, isLchown: boolean, new_uid: number, new_gid: number, cred: Cred, cb: BFSOneArgCallback): void {\n\t\ttry {\n\t\t\tthis.chownSync(p, isLchown, new_uid, new_gid, cred);\n\t\t\tcb();\n\t\t} catch (e) {\n\t\t\tcb(e);\n\t\t}\n\t}\n\n\tpublic utimes(p: string, atime: Date, mtime: Date, cred: Cred, cb: BFSOneArgCallback): void {\n\t\ttry {\n\t\t\tthis.utimesSync(p, atime, mtime, cred);\n\t\t\tcb();\n\t\t} catch (e) {\n\t\t\tcb(e);\n\t\t}\n\t}\n\n\tpublic link(srcpath: string, dstpath: string, cred: Cred, cb: BFSOneArgCallback): void {\n\t\ttry {\n\t\t\tthis.linkSync(srcpath, dstpath, cred);\n\t\t\tcb();\n\t\t} catch (e) {\n\t\t\tcb(e);\n\t\t}\n\t}\n\n\tpublic symlink(srcpath: string, dstpath: string, type: string, cred: Cred, cb: BFSOneArgCallback): void {\n\t\ttry {\n\t\t\tthis.symlinkSync(srcpath, dstpath, type, cred);\n\t\t\tcb();\n\t\t} catch (e) {\n\t\t\tcb(e);\n\t\t}\n\t}\n\n\tpublic readlink(p: string, cred: Cred, cb: BFSCallback<string>): void {\n\t\ttry {\n\t\t\tcb(null, this.readlinkSync(p, cred));\n\t\t} catch (e) {\n\t\t\tcb(e);\n\t\t}\n\t}\n}\n"]}