{"version":3,"file":"mutex.js","sourceRoot":"","sources":["../../../src/generic/mutex.ts"],"names":[],"mappings":";;AAAA,wDAAmD;AAGnD;;;GAGG;AACH;IAAA;QACS,YAAO,GAAY,KAAK,CAAC;QACzB,aAAQ,GAAoB,EAAE,CAAC;IA2CxC,CAAC;IAzCO,oBAAI,GAAX,UAAY,EAAiB;QAC5B,IAAI,IAAI,CAAC,OAAO,EAAE;YACjB,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC;YACvB,OAAO;SACP;QACD,IAAI,CAAC,OAAO,GAAG,IAAI,CAAC;QACpB,EAAE,EAAE,CAAC;IACN,CAAC;IAEM,sBAAM,GAAb;QACC,IAAI,CAAC,IAAI,CAAC,OAAO,EAAE;YAClB,MAAM,IAAI,KAAK,CAAC,8BAA8B,CAAC,CAAC;SAChD;QAED,IAAM,IAAI,GAAG,IAAI,CAAC,QAAQ,CAAC,KAAK,EAAE,CAAC;QACnC,kDAAkD;QAClD,oDAAoD;QACpD,gDAAgD;QAChD,oDAAoD;QACpD,oDAAoD;QACpD,+BAA+B;QAC/B,IAAI,IAAI,EAAE;YACT,IAAA,sBAAY,EAAC,IAAI,CAAC,CAAC;YACnB,OAAO;SACP;QAED,IAAI,CAAC,OAAO,GAAG,KAAK,CAAC;IACtB,CAAC;IAEM,uBAAO,GAAd;QACC,IAAI,IAAI,CAAC,OAAO,EAAE;YACjB,OAAO,KAAK,CAAC;SACb;QAED,IAAI,CAAC,OAAO,GAAG,IAAI,CAAC;QACpB,OAAO,IAAI,CAAC;IACb,CAAC;IAEM,wBAAQ,GAAf;QACC,OAAO,IAAI,CAAC,OAAO,CAAC;IACrB,CAAC;IACF,YAAC;AAAD,CAAC,AA7CD,IA6CC","sourcesContent":["import setImmediate from '../generic/setImmediate';\n\nexport type MutexCallback = () => void;\n/**\n * Non-recursive mutex\n * @hidden\n */\nexport default class Mutex {\n\tprivate _locked: boolean = false;\n\tprivate _waiters: MutexCallback[] = [];\n\n\tpublic lock(cb: MutexCallback): void {\n\t\tif (this._locked) {\n\t\t\tthis._waiters.push(cb);\n\t\t\treturn;\n\t\t}\n\t\tthis._locked = true;\n\t\tcb();\n\t}\n\n\tpublic unlock(): void {\n\t\tif (!this._locked) {\n\t\t\tthrow new Error('unlock of a non-locked mutex');\n\t\t}\n\n\t\tconst next = this._waiters.shift();\n\t\t// don't unlock - we want to queue up next for the\n\t\t// _end_ of the current task execution, but we don't\n\t\t// want it to be called inline with whatever the\n\t\t// current stack is.  This way we still get the nice\n\t\t// behavior that an unlock immediately followed by a\n\t\t// lock won't cause starvation.\n\t\tif (next) {\n\t\t\tsetImmediate(next);\n\t\t\treturn;\n\t\t}\n\n\t\tthis._locked = false;\n\t}\n\n\tpublic tryLock(): boolean {\n\t\tif (this._locked) {\n\t\t\treturn false;\n\t\t}\n\n\t\tthis._locked = true;\n\t\treturn true;\n\t}\n\n\tpublic isLocked(): boolean {\n\t\treturn this._locked;\n\t}\n}\n"]}