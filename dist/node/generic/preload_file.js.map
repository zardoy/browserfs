{"version":3,"file":"preload_file.js","sourceRoot":"","sources":["../../../src/generic/preload_file.ts"],"names":[],"mappings":"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","sourcesContent":["import { BaseFile, File } from '../core/file';\nimport { FileSystem, BFSOneArgCallback, BFSCallback, BFSThreeArgCallback } from '../core/file_system';\nimport Stats from '../core/stats';\nimport { FileFlag } from '../core/file_flag';\nimport { ApiError, ErrorCode } from '../core/api_error';\nimport fs from '../core/node_fs';\nimport { emptyBuffer } from '../core/util';\nimport { Buffer } from 'buffer';\n\n/**\n * An implementation of the File interface that operates on a file that is\n * completely in-memory. PreloadFiles are backed by a Buffer.\n *\n * This is also an abstract class, as it lacks an implementation of 'sync' and\n * 'close'. Each filesystem that wishes to use this file representation must\n * extend this class and implement those two methods.\n * @todo 'close' lever that disables functionality once closed.\n */\nexport default class PreloadFile<T extends FileSystem> extends BaseFile {\n\tprotected _fs: T;\n\tprotected _pos: number = 0;\n\tprotected _path: string;\n\tprotected _stat: Stats;\n\tprotected _flag: FileFlag;\n\tprotected _buffer: Buffer;\n\tprotected _dirty: boolean = false;\n\t/**\n\t * Creates a file with the given path and, optionally, the given contents. Note\n\t * that, if contents is specified, it will be mutated by the file!\n\t * @param _fs The file system that created the file.\n\t * @param _path\n\t * @param _mode The mode that the file was opened using.\n\t *   Dictates permissions and where the file pointer starts.\n\t * @param _stat The stats object for the given file.\n\t *   PreloadFile will mutate this object. Note that this object must contain\n\t *   the appropriate mode that the file was opened as.\n\t * @param contents A buffer containing the entire\n\t *   contents of the file. PreloadFile will mutate this buffer. If not\n\t *   specified, we assume it is a new file.\n\t */\n\tconstructor(_fs: T, _path: string, _flag: FileFlag, _stat: Stats, contents?: Buffer) {\n\t\tsuper();\n\t\tthis._fs = _fs;\n\t\tthis._path = _path;\n\t\tthis._flag = _flag;\n\t\tthis._stat = _stat;\n\t\tthis._buffer = contents ? contents : emptyBuffer();\n\t\t// Note: This invariant is *not* maintained once the file starts getting\n\t\t// modified.\n\t\t// Note: Only actually matters if file is readable, as writeable modes may\n\t\t// truncate/append to file.\n\t\tif (this._stat.size !== this._buffer.length && this._flag.isReadable()) {\n\t\t\tthrow new Error(`Invalid buffer: Buffer is ${this._buffer.length} long, yet Stats object specifies that file is ${this._stat.size} long.`);\n\t\t}\n\t}\n\n\t/**\n\t * NONSTANDARD: Get the underlying buffer for this file. !!DO NOT MUTATE!! Will mess up dirty tracking.\n\t */\n\tpublic getBuffer(): Buffer {\n\t\treturn this._buffer;\n\t}\n\n\t/**\n\t * NONSTANDARD: Get underlying stats for this file. !!DO NOT MUTATE!!\n\t */\n\tpublic getStats(): Stats {\n\t\treturn this._stat;\n\t}\n\n\tpublic getFlag(): FileFlag {\n\t\treturn this._flag;\n\t}\n\n\t/**\n\t * Get the path to this file.\n\t * @return [String] The path to the file.\n\t */\n\tpublic getPath(): string {\n\t\treturn this._path;\n\t}\n\n\t/**\n\t * Get the current file position.\n\t *\n\t * We emulate the following bug mentioned in the Node documentation:\n\t * > On Linux, positional writes don't work when the file is opened in append\n\t *   mode. The kernel ignores the position argument and always appends the data\n\t *   to the end of the file.\n\t * @return [Number] The current file position.\n\t */\n\tpublic getPos(): number {\n\t\tif (this._flag.isAppendable()) {\n\t\t\treturn this._stat.size;\n\t\t}\n\t\treturn this._pos;\n\t}\n\n\t/**\n\t * Advance the current file position by the indicated number of positions.\n\t * @param [Number] delta\n\t */\n\tpublic advancePos(delta: number): number {\n\t\treturn (this._pos += delta);\n\t}\n\n\t/**\n\t * Set the file position.\n\t * @param [Number] newPos\n\t */\n\tpublic setPos(newPos: number): number {\n\t\treturn (this._pos = newPos);\n\t}\n\n\t/**\n\t * **Core**: Asynchronous sync. Must be implemented by subclasses of this\n\t * class.\n\t * @param [Function(BrowserFS.ApiError)] cb\n\t */\n\tpublic sync(cb: BFSOneArgCallback): void {\n\t\ttry {\n\t\t\tthis.syncSync();\n\t\t\tcb();\n\t\t} catch (e) {\n\t\t\tcb(e);\n\t\t}\n\t}\n\n\t/**\n\t * **Core**: Synchronous sync.\n\t */\n\tpublic syncSync(): void {\n\t\tthrow new ApiError(ErrorCode.ENOTSUP);\n\t}\n\n\t/**\n\t * **Core**: Asynchronous close. Must be implemented by subclasses of this\n\t * class.\n\t * @param [Function(BrowserFS.ApiError)] cb\n\t */\n\tpublic close(cb: BFSOneArgCallback): void {\n\t\ttry {\n\t\t\tthis.closeSync();\n\t\t\tcb();\n\t\t} catch (e) {\n\t\t\tcb(e);\n\t\t}\n\t}\n\n\t/**\n\t * **Core**: Synchronous close.\n\t */\n\tpublic closeSync(): void {\n\t\tthrow new ApiError(ErrorCode.ENOTSUP);\n\t}\n\n\t/**\n\t * Asynchronous `stat`.\n\t * @param [Function(BrowserFS.ApiError, BrowserFS.node.fs.Stats)] cb\n\t */\n\tpublic stat(cb: BFSCallback<Stats>): void {\n\t\ttry {\n\t\t\tcb(null, Stats.clone(this._stat));\n\t\t} catch (e) {\n\t\t\tcb(e);\n\t\t}\n\t}\n\n\t/**\n\t * Synchronous `stat`.\n\t */\n\tpublic statSync(): Stats {\n\t\treturn Stats.clone(this._stat);\n\t}\n\n\t/**\n\t * Asynchronous truncate.\n\t * @param [Number] len\n\t * @param [Function(BrowserFS.ApiError)] cb\n\t */\n\tpublic truncate(len: number, cb: BFSOneArgCallback): void {\n\t\ttry {\n\t\t\tthis.truncateSync(len);\n\t\t\tif (this._flag.isSynchronous() && !fs.getRootFS()!.supportsSynch()) {\n\t\t\t\tthis.sync(cb);\n\t\t\t}\n\t\t\tcb();\n\t\t} catch (e) {\n\t\t\treturn cb(e);\n\t\t}\n\t}\n\n\t/**\n\t * Synchronous truncate.\n\t * @param [Number] len\n\t */\n\tpublic truncateSync(len: number): void {\n\t\tthis._dirty = true;\n\t\tif (!this._flag.isWriteable()) {\n\t\t\tthrow new ApiError(ErrorCode.EPERM, 'File not opened with a writeable mode.');\n\t\t}\n\t\tthis._stat.mtimeMs = Date.now();\n\t\tif (len > this._buffer.length) {\n\t\t\tconst buf = Buffer.alloc(len - this._buffer.length, 0);\n\t\t\t// Write will set @_stat.size for us.\n\t\t\tthis.writeSync(buf, 0, buf.length, this._buffer.length);\n\t\t\tif (this._flag.isSynchronous() && fs.getRootFS()!.supportsSynch()) {\n\t\t\t\tthis.syncSync();\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tthis._stat.size = len;\n\t\t// Truncate buffer to 'len'.\n\t\tconst newBuff = Buffer.alloc(len);\n\t\tthis._buffer.copy(newBuff, 0, 0, len);\n\t\tthis._buffer = newBuff;\n\t\tif (this._flag.isSynchronous() && fs.getRootFS()!.supportsSynch()) {\n\t\t\tthis.syncSync();\n\t\t}\n\t}\n\n\t/**\n\t * Write buffer to the file.\n\t * Note that it is unsafe to use fs.write multiple times on the same file\n\t * without waiting for the callback.\n\t * @param [BrowserFS.node.Buffer] buffer Buffer containing the data to write to\n\t *  the file.\n\t * @param [Number] offset Offset in the buffer to start reading data from.\n\t * @param [Number] length The amount of bytes to write to the file.\n\t * @param [Number] position Offset from the beginning of the file where this\n\t *   data should be written. If position is null, the data will be written at\n\t *   the current position.\n\t * @param [Function(BrowserFS.ApiError, Number, BrowserFS.node.Buffer)]\n\t *   cb The number specifies the number of bytes written into the file.\n\t */\n\tpublic write(buffer: Buffer, offset: number, length: number, position: number, cb: BFSThreeArgCallback<number, Buffer>): void {\n\t\ttry {\n\t\t\tcb(null, this.writeSync(buffer, offset, length, position), buffer);\n\t\t} catch (e) {\n\t\t\tcb(e);\n\t\t}\n\t}\n\n\t/**\n\t * Write buffer to the file.\n\t * Note that it is unsafe to use fs.writeSync multiple times on the same file\n\t * without waiting for the callback.\n\t * @param [BrowserFS.node.Buffer] buffer Buffer containing the data to write to\n\t *  the file.\n\t * @param [Number] offset Offset in the buffer to start reading data from.\n\t * @param [Number] length The amount of bytes to write to the file.\n\t * @param [Number] position Offset from the beginning of the file where this\n\t *   data should be written. If position is null, the data will be written at\n\t *   the current position.\n\t * @return [Number]\n\t */\n\tpublic writeSync(buffer: Buffer, offset: number, length: number, position: number): number {\n\t\tthis._dirty = true;\n\t\tif (position === undefined || position === null) {\n\t\t\tposition = this.getPos();\n\t\t}\n\t\tif (!this._flag.isWriteable()) {\n\t\t\tthrow new ApiError(ErrorCode.EPERM, 'File not opened with a writeable mode.');\n\t\t}\n\t\tconst endFp = position + length;\n\t\tif (endFp > this._stat.size) {\n\t\t\tthis._stat.size = endFp;\n\t\t\tif (endFp > this._buffer.length) {\n\t\t\t\t// Extend the buffer!\n\t\t\t\tconst newBuff = Buffer.alloc(endFp);\n\t\t\t\tthis._buffer.copy(newBuff);\n\t\t\t\tthis._buffer = newBuff;\n\t\t\t}\n\t\t}\n\t\tconst len = buffer.copy(this._buffer, position, offset, offset + length);\n\t\tthis._stat.mtimeMs = Date.now();\n\t\tif (this._flag.isSynchronous()) {\n\t\t\tthis.syncSync();\n\t\t\treturn len;\n\t\t}\n\t\tthis.setPos(position + len);\n\t\treturn len;\n\t}\n\n\t/**\n\t * Read data from the file.\n\t * @param [BrowserFS.node.Buffer] buffer The buffer that the data will be\n\t *   written to.\n\t * @param [Number] offset The offset within the buffer where writing will\n\t *   start.\n\t * @param [Number] length An integer specifying the number of bytes to read.\n\t * @param [Number] position An integer specifying where to begin reading from\n\t *   in the file. If position is null, data will be read from the current file\n\t *   position.\n\t * @param [Function(BrowserFS.ApiError, Number, BrowserFS.node.Buffer)] cb The\n\t *   number is the number of bytes read\n\t */\n\tpublic read(buffer: Buffer, offset: number, length: number, position: number, cb: BFSThreeArgCallback<number, Buffer>): void {\n\t\ttry {\n\t\t\tcb(null, this.readSync(buffer, offset, length, position), buffer);\n\t\t} catch (e) {\n\t\t\tcb(e);\n\t\t}\n\t}\n\n\t/**\n\t * Read data from the file.\n\t * @param [BrowserFS.node.Buffer] buffer The buffer that the data will be\n\t *   written to.\n\t * @param [Number] offset The offset within the buffer where writing will\n\t *   start.\n\t * @param [Number] length An integer specifying the number of bytes to read.\n\t * @param [Number] position An integer specifying where to begin reading from\n\t *   in the file. If position is null, data will be read from the current file\n\t *   position.\n\t * @return [Number]\n\t */\n\tpublic readSync(buffer: Buffer, offset: number, length: number, position: number): number {\n\t\tif (!this._flag.isReadable()) {\n\t\t\tthrow new ApiError(ErrorCode.EPERM, 'File not opened with a readable mode.');\n\t\t}\n\t\tif (position === undefined || position === null) {\n\t\t\tposition = this.getPos();\n\t\t}\n\t\tconst endRead = position + length;\n\t\tif (endRead > this._stat.size) {\n\t\t\tlength = this._stat.size - position;\n\t\t}\n\t\tconst rv = this._buffer.copy(buffer, offset, position, position + length);\n\t\tthis._stat.atimeMs = Date.now();\n\t\tthis._pos = position + length;\n\t\treturn rv;\n\t}\n\n\t/**\n\t * Asynchronous `fchmod`.\n\t * @param [Number|String] mode\n\t * @param [Function(BrowserFS.ApiError)] cb\n\t */\n\tpublic chmod(mode: number, cb: BFSOneArgCallback): void {\n\t\ttry {\n\t\t\tthis.chmodSync(mode);\n\t\t\tcb();\n\t\t} catch (e) {\n\t\t\tcb(e);\n\t\t}\n\t}\n\n\t/**\n\t * Synchronous `fchmod`.\n\t * @param [Number] mode\n\t */\n\tpublic chmodSync(mode: number): void {\n\t\tif (!this._fs.supportsProps()) {\n\t\t\tthrow new ApiError(ErrorCode.ENOTSUP);\n\t\t}\n\t\tthis._dirty = true;\n\t\tthis._stat.chmod(mode);\n\t\tthis.syncSync();\n\t}\n\n\t/**\n\t * Asynchronous `fchown`.\n\t * @param [Number] uid\n\t * @param [Number] gid\n\t * @param [Function(BrowserFS.ApiError)] cb\n\t */\n\tpublic chown(uid: number, gid: number, cb: BFSOneArgCallback): void {\n\t\ttry {\n\t\t\tthis.chownSync(uid, gid);\n\t\t\tcb();\n\t\t} catch (e) {\n\t\t\tcb(e);\n\t\t}\n\t}\n\n\t/**\n\t * Synchronous `fchown`.\n\t * @param [Number] uid\n\t * @param [Number] gid\n\t */\n\tpublic chownSync(uid: number, gid: number): void {\n\t\tif (!this._fs.supportsProps()) {\n\t\t\tthrow new ApiError(ErrorCode.ENOTSUP);\n\t\t}\n\t\tthis._dirty = true;\n\t\tthis._stat.chown(uid, gid);\n\t\tthis.syncSync();\n\t}\n\n\tprotected isDirty(): boolean {\n\t\treturn this._dirty;\n\t}\n\n\t/**\n\t * Resets the dirty bit. Should only be called after a sync has completed successfully.\n\t */\n\tprotected resetDirty() {\n\t\tthis._dirty = false;\n\t}\n}\n\n/**\n * File class for the InMemory and XHR file systems.\n * Doesn't sync to anything, so it works nicely for memory-only files.\n */\nexport class NoSyncFile<T extends FileSystem> extends PreloadFile<T> implements File {\n\tconstructor(_fs: T, _path: string, _flag: FileFlag, _stat: Stats, contents?: Buffer) {\n\t\tsuper(_fs, _path, _flag, _stat, contents);\n\t}\n\t/**\n\t * Asynchronous sync. Doesn't do anything, simply calls the cb.\n\t * @param [Function(BrowserFS.ApiError)] cb\n\t */\n\tpublic sync(cb: BFSOneArgCallback): void {\n\t\tcb();\n\t}\n\t/**\n\t * Synchronous sync. Doesn't do anything.\n\t */\n\tpublic syncSync(): void {\n\t\t// NOP.\n\t}\n\t/**\n\t * Asynchronous close. Doesn't do anything, simply calls the cb.\n\t * @param [Function(BrowserFS.ApiError)] cb\n\t */\n\tpublic close(cb: BFSOneArgCallback): void {\n\t\tcb();\n\t}\n\t/**\n\t * Synchronous close. Doesn't do anything.\n\t */\n\tpublic closeSync(): void {\n\t\t// NOP.\n\t}\n}\n"]}